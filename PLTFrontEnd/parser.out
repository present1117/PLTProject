Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    WHITESPACE
    EMPTYLINE

Grammar

Rule 0     S' -> input_stmt
Rule 1     input_stmt -> piece_stmt board_stmt player_stmt rule_stmt function_stmt
Rule 2     piece_stmt -> PIECE : NEWLINE INDENT piece_expr DEDENT
Rule 3     piece_expr -> STRING NUMBER NEWLINE
Rule 4     piece_expr -> STRING NEWLINE
Rule 5     piece_expr -> piece_expr STRING NEWLINE
Rule 6     piece_expr -> piece_expr STRING NUMBER NEWLINE
Rule 7     board_stmt -> BOARD : NEWLINE INDENT NUMBER NUMBER NEWLINE DEDENT
Rule 8     player_stmt -> PLAYER : NEWLINE INDENT NUMBER NEWLINE DEDENT
Rule 9     rule_stmt -> RULE : NEWLINE INDENT action_stmt DEDENT
Rule 10    action_stmt -> ACTION : = ID NEWLINE
Rule 11    action_stmt -> action_stmt ACTION : = ID NEWLINE
Rule 12    function_stmt -> FUNCTION : NEWLINE INDENT global_assign_stmt funcdef DEDENT
Rule 13    function_stmt -> FUNCTION : NEWLINE INDENT global_assign_stmt init_assign_stmt funcdef DEDENT
Rule 14    stmt -> simple_stmt
Rule 15    stmt -> compound_stmt
Rule 16    simple_stmt -> assign_stmt
Rule 17    simple_stmt -> flow_stmt
Rule 18    compound_stmt -> func_expr NEWLINE
Rule 19    compound_stmt -> for_stmt
Rule 20    compound_stmt -> if_stmt
Rule 21    compound_stmt -> while_stmt
Rule 22    assign_stmt -> power : = expr NEWLINE
Rule 23    init_assign_stmt -> DEF INIT : NEWLINE INDENT init_stmt DEDENT
Rule 24    init_stmt -> STRING NUMBER position NEWLINE
Rule 25    init_stmt -> init_stmt STRING NUMBER position NEWLINE
Rule 26    global_assign_stmt -> global_assign_stmt GLOBAL assign_stmt
Rule 27    global_assign_stmt -> empty
Rule 28    flow_stmt -> break_stmt
Rule 29    flow_stmt -> continue_stmt
Rule 30    flow_stmt -> return_stmt
Rule 31    funcdef -> DEF ID parameters : suite
Rule 32    funcdef -> DEF ID : suite
Rule 33    funcdef -> funcdef DEF ID parameters : suite
Rule 34    funcdef -> funcdef DEF ID : suite
Rule 35    parameters -> parameters , parameter
Rule 36    parameters -> parameter
Rule 37    parameter -> ID
Rule 38    expr -> or_test
Rule 39    or_test -> and_test
Rule 40    or_test -> or_test OR and_test
Rule 41    and_test -> not_test
Rule 42    and_test -> and_test AND not_test
Rule 43    not_test -> NOT not_test
Rule 44    not_test -> comparison
Rule 45    comparison -> operand
Rule 46    comparison -> comparison = operand
Rule 47    comparison -> comparison > operand
Rule 48    comparison -> comparison < operand
Rule 49    comparison -> comparison > = operand
Rule 50    comparison -> comparison < = operand
Rule 51    comparison -> comparison ~ = operand
Rule 52    operand -> term
Rule 53    operand -> operand + term
Rule 54    operand -> operand - term
Rule 55    term -> factor
Rule 56    term -> term * factor
Rule 57    term -> term / factor
Rule 58    term -> term % factor
Rule 59    factor -> power
Rule 60    factor -> + factor
Rule 61    factor -> - factor
Rule 62    power -> atom
Rule 63    power -> power trailer
Rule 64    atom -> array
Rule 65    atom -> position
Rule 66    atom -> ID
Rule 67    atom -> STRING
Rule 68    atom -> NUMBER
Rule 69    atom -> BOOLEAN
Rule 70    atom -> NIL
Rule 71    atom -> func_expr
Rule 72    atom -> ( expr )
Rule 73    position -> ( expr , expr )
Rule 74    array -> [ parameter_list ]
Rule 75    trailer -> . ID
Rule 76    trailer -> [ expr ]
Rule 77    func_expr -> ID ( )
Rule 78    func_expr -> ID ( parameter_list )
Rule 79    parameter_list -> expr
Rule 80    parameter_list -> parameter_list , expr
Rule 81    for_stmt -> FOR ID : = NUMBER TO NUMBER : suite
Rule 82    for_stmt -> FOR ID IN expr : suite
Rule 83    if_stmt -> IF expr : suite
Rule 84    if_stmt -> IF expr : suite elseif_stmt
Rule 85    if_stmt -> IF expr : suite ELSE : suite
Rule 86    if_stmt -> IF expr : suite elseif_stmt ELSE : suite
Rule 87    elseif_stmt -> ELSEIF expr : suite
Rule 88    elseif_stmt -> elseif_stmt ELSEIF expr : suite
Rule 89    while_stmt -> WHILE expr : suite
Rule 90    suite -> NEWLINE
Rule 91    suite -> NEWLINE INDENT suite_stmt DEDENT
Rule 92    suite_stmt -> stmt
Rule 93    suite_stmt -> suite_stmt stmt
Rule 94    return_stmt -> RETURN expr NEWLINE
Rule 95    continue_stmt -> CONTINUE NEWLINE
Rule 96    break_stmt -> BREAK NEWLINE
Rule 97    empty -> <empty>

Terminals, with rules where they appear

%                    : 58
(                    : 72 73 77 78
)                    : 72 73 77 78
*                    : 56
+                    : 53 60
,                    : 35 73 80
-                    : 54 61
.                    : 75
/                    : 57
:                    : 2 7 8 9 10 11 12 13 22 23 31 32 33 34 81 81 82 83 84 85 85 86 86 87 88 89
<                    : 48 50
=                    : 10 11 22 46 49 50 51 81
>                    : 47 49
ACTION               : 10 11
AND                  : 42
BOARD                : 7
BOOLEAN              : 69
BREAK                : 96
COMMENT              : 
CONTINUE             : 95
DEDENT               : 2 7 8 9 12 13 23 91
DEF                  : 23 31 32 33 34
ELSE                 : 85 86
ELSEIF               : 87 88
EMPTYLINE            : 
FOR                  : 81 82
FUNCTION             : 12 13
GLOBAL               : 26
ID                   : 10 11 31 32 33 34 37 66 75 77 78 81 82
IF                   : 83 84 85 86
IN                   : 82
INDENT               : 2 7 8 9 12 13 23 91
INIT                 : 23
NEWLINE              : 2 3 4 5 6 7 7 8 8 9 10 11 12 13 18 22 23 24 25 90 91 94 95 96
NIL                  : 70
NOT                  : 43
NUMBER               : 3 6 7 7 8 24 25 68 81 81
OR                   : 40
PIECE                : 2
PLAYER               : 8
RETURN               : 94
RULE                 : 9
STRING               : 3 4 5 6 24 25 67
TO                   : 81
WHILE                : 89
WHITESPACE           : 
[                    : 74 76
]                    : 74 76
error                : 
~                    : 51

Nonterminals, with rules where they appear

action_stmt          : 9 11
and_test             : 39 40 42
array                : 64
assign_stmt          : 16 26
atom                 : 62
board_stmt           : 1
break_stmt           : 28
comparison           : 44 46 47 48 49 50 51
compound_stmt        : 15
continue_stmt        : 29
elseif_stmt          : 84 86 88
empty                : 27
expr                 : 22 72 73 73 76 79 80 82 83 84 85 86 87 88 89 94
factor               : 55 56 57 58 60 61
flow_stmt            : 17
for_stmt             : 19
func_expr            : 18 71
funcdef              : 12 13 33 34
function_stmt        : 1
global_assign_stmt   : 12 13 26
if_stmt              : 20
init_assign_stmt     : 13
init_stmt            : 23 25
input_stmt           : 0
not_test             : 41 42 43
operand              : 45 46 47 48 49 50 51 53 54
or_test              : 38 40
parameter            : 35 36
parameter_list       : 74 78 80
parameters           : 31 33 35
piece_expr           : 2 5 6
piece_stmt           : 1
player_stmt          : 1
position             : 24 25 65
power                : 22 59 63
return_stmt          : 30
rule_stmt            : 1
simple_stmt          : 14
stmt                 : 92 93
suite                : 31 32 33 34 81 82 83 84 85 85 86 86 87 88 89
suite_stmt           : 91 93
term                 : 52 53 54 56 57 58
trailer              : 63
while_stmt           : 21

Parsing method: LALR

state 0

    (0) S' -> . input_stmt
    (1) input_stmt -> . piece_stmt board_stmt player_stmt rule_stmt function_stmt
    (2) piece_stmt -> . PIECE : NEWLINE INDENT piece_expr DEDENT

    PIECE           shift and go to state 2

    piece_stmt                     shift and go to state 1
    input_stmt                     shift and go to state 3

state 1

    (1) input_stmt -> piece_stmt . board_stmt player_stmt rule_stmt function_stmt
    (7) board_stmt -> . BOARD : NEWLINE INDENT NUMBER NUMBER NEWLINE DEDENT

    BOARD           shift and go to state 5

    board_stmt                     shift and go to state 4

state 2

    (2) piece_stmt -> PIECE . : NEWLINE INDENT piece_expr DEDENT

    :               shift and go to state 6


state 3

    (0) S' -> input_stmt .



state 4

    (1) input_stmt -> piece_stmt board_stmt . player_stmt rule_stmt function_stmt
    (8) player_stmt -> . PLAYER : NEWLINE INDENT NUMBER NEWLINE DEDENT

    PLAYER          shift and go to state 7

    player_stmt                    shift and go to state 8

state 5

    (7) board_stmt -> BOARD . : NEWLINE INDENT NUMBER NUMBER NEWLINE DEDENT

    :               shift and go to state 9


state 6

    (2) piece_stmt -> PIECE : . NEWLINE INDENT piece_expr DEDENT

    NEWLINE         shift and go to state 10


state 7

    (8) player_stmt -> PLAYER . : NEWLINE INDENT NUMBER NEWLINE DEDENT

    :               shift and go to state 11


state 8

    (1) input_stmt -> piece_stmt board_stmt player_stmt . rule_stmt function_stmt
    (9) rule_stmt -> . RULE : NEWLINE INDENT action_stmt DEDENT

    RULE            shift and go to state 12

    rule_stmt                      shift and go to state 13

state 9

    (7) board_stmt -> BOARD : . NEWLINE INDENT NUMBER NUMBER NEWLINE DEDENT

    NEWLINE         shift and go to state 14


state 10

    (2) piece_stmt -> PIECE : NEWLINE . INDENT piece_expr DEDENT

    INDENT          shift and go to state 15


state 11

    (8) player_stmt -> PLAYER : . NEWLINE INDENT NUMBER NEWLINE DEDENT

    NEWLINE         shift and go to state 16


state 12

    (9) rule_stmt -> RULE . : NEWLINE INDENT action_stmt DEDENT

    :               shift and go to state 17


state 13

    (1) input_stmt -> piece_stmt board_stmt player_stmt rule_stmt . function_stmt
    (12) function_stmt -> . FUNCTION : NEWLINE INDENT global_assign_stmt funcdef DEDENT
    (13) function_stmt -> . FUNCTION : NEWLINE INDENT global_assign_stmt init_assign_stmt funcdef DEDENT

    FUNCTION        shift and go to state 18

    function_stmt                  shift and go to state 19

state 14

    (7) board_stmt -> BOARD : NEWLINE . INDENT NUMBER NUMBER NEWLINE DEDENT

    INDENT          shift and go to state 20


state 15

    (2) piece_stmt -> PIECE : NEWLINE INDENT . piece_expr DEDENT
    (3) piece_expr -> . STRING NUMBER NEWLINE
    (4) piece_expr -> . STRING NEWLINE
    (5) piece_expr -> . piece_expr STRING NEWLINE
    (6) piece_expr -> . piece_expr STRING NUMBER NEWLINE

    STRING          shift and go to state 21

    piece_expr                     shift and go to state 22

state 16

    (8) player_stmt -> PLAYER : NEWLINE . INDENT NUMBER NEWLINE DEDENT

    INDENT          shift and go to state 23


state 17

    (9) rule_stmt -> RULE : . NEWLINE INDENT action_stmt DEDENT

    NEWLINE         shift and go to state 24


state 18

    (12) function_stmt -> FUNCTION . : NEWLINE INDENT global_assign_stmt funcdef DEDENT
    (13) function_stmt -> FUNCTION . : NEWLINE INDENT global_assign_stmt init_assign_stmt funcdef DEDENT

    :               shift and go to state 25


state 19

    (1) input_stmt -> piece_stmt board_stmt player_stmt rule_stmt function_stmt .

    $end            reduce using rule 1 (input_stmt -> piece_stmt board_stmt player_stmt rule_stmt function_stmt .)


state 20

    (7) board_stmt -> BOARD : NEWLINE INDENT . NUMBER NUMBER NEWLINE DEDENT

    NUMBER          shift and go to state 26


state 21

    (3) piece_expr -> STRING . NUMBER NEWLINE
    (4) piece_expr -> STRING . NEWLINE

    NUMBER          shift and go to state 28
    NEWLINE         shift and go to state 27


state 22

    (2) piece_stmt -> PIECE : NEWLINE INDENT piece_expr . DEDENT
    (5) piece_expr -> piece_expr . STRING NEWLINE
    (6) piece_expr -> piece_expr . STRING NUMBER NEWLINE

    DEDENT          shift and go to state 29
    STRING          shift and go to state 30


state 23

    (8) player_stmt -> PLAYER : NEWLINE INDENT . NUMBER NEWLINE DEDENT

    NUMBER          shift and go to state 31


state 24

    (9) rule_stmt -> RULE : NEWLINE . INDENT action_stmt DEDENT

    INDENT          shift and go to state 32


state 25

    (12) function_stmt -> FUNCTION : . NEWLINE INDENT global_assign_stmt funcdef DEDENT
    (13) function_stmt -> FUNCTION : . NEWLINE INDENT global_assign_stmt init_assign_stmt funcdef DEDENT

    NEWLINE         shift and go to state 33


state 26

    (7) board_stmt -> BOARD : NEWLINE INDENT NUMBER . NUMBER NEWLINE DEDENT

    NUMBER          shift and go to state 34


state 27

    (4) piece_expr -> STRING NEWLINE .

    DEDENT          reduce using rule 4 (piece_expr -> STRING NEWLINE .)
    STRING          reduce using rule 4 (piece_expr -> STRING NEWLINE .)


state 28

    (3) piece_expr -> STRING NUMBER . NEWLINE

    NEWLINE         shift and go to state 35


state 29

    (2) piece_stmt -> PIECE : NEWLINE INDENT piece_expr DEDENT .

    BOARD           reduce using rule 2 (piece_stmt -> PIECE : NEWLINE INDENT piece_expr DEDENT .)


state 30

    (5) piece_expr -> piece_expr STRING . NEWLINE
    (6) piece_expr -> piece_expr STRING . NUMBER NEWLINE

    NEWLINE         shift and go to state 36
    NUMBER          shift and go to state 37


state 31

    (8) player_stmt -> PLAYER : NEWLINE INDENT NUMBER . NEWLINE DEDENT

    NEWLINE         shift and go to state 38


state 32

    (9) rule_stmt -> RULE : NEWLINE INDENT . action_stmt DEDENT
    (10) action_stmt -> . ACTION : = ID NEWLINE
    (11) action_stmt -> . action_stmt ACTION : = ID NEWLINE

    ACTION          shift and go to state 39

    action_stmt                    shift and go to state 40

state 33

    (12) function_stmt -> FUNCTION : NEWLINE . INDENT global_assign_stmt funcdef DEDENT
    (13) function_stmt -> FUNCTION : NEWLINE . INDENT global_assign_stmt init_assign_stmt funcdef DEDENT

    INDENT          shift and go to state 41


state 34

    (7) board_stmt -> BOARD : NEWLINE INDENT NUMBER NUMBER . NEWLINE DEDENT

    NEWLINE         shift and go to state 42


state 35

    (3) piece_expr -> STRING NUMBER NEWLINE .

    DEDENT          reduce using rule 3 (piece_expr -> STRING NUMBER NEWLINE .)
    STRING          reduce using rule 3 (piece_expr -> STRING NUMBER NEWLINE .)


state 36

    (5) piece_expr -> piece_expr STRING NEWLINE .

    DEDENT          reduce using rule 5 (piece_expr -> piece_expr STRING NEWLINE .)
    STRING          reduce using rule 5 (piece_expr -> piece_expr STRING NEWLINE .)


state 37

    (6) piece_expr -> piece_expr STRING NUMBER . NEWLINE

    NEWLINE         shift and go to state 43


state 38

    (8) player_stmt -> PLAYER : NEWLINE INDENT NUMBER NEWLINE . DEDENT

    DEDENT          shift and go to state 44


state 39

    (10) action_stmt -> ACTION . : = ID NEWLINE

    :               shift and go to state 45


state 40

    (9) rule_stmt -> RULE : NEWLINE INDENT action_stmt . DEDENT
    (11) action_stmt -> action_stmt . ACTION : = ID NEWLINE

    DEDENT          shift and go to state 46
    ACTION          shift and go to state 47


state 41

    (12) function_stmt -> FUNCTION : NEWLINE INDENT . global_assign_stmt funcdef DEDENT
    (13) function_stmt -> FUNCTION : NEWLINE INDENT . global_assign_stmt init_assign_stmt funcdef DEDENT
    (26) global_assign_stmt -> . global_assign_stmt GLOBAL assign_stmt
    (27) global_assign_stmt -> . empty
    (97) empty -> .

    GLOBAL          reduce using rule 97 (empty -> .)
    DEF             reduce using rule 97 (empty -> .)

    empty                          shift and go to state 48
    global_assign_stmt             shift and go to state 49

state 42

    (7) board_stmt -> BOARD : NEWLINE INDENT NUMBER NUMBER NEWLINE . DEDENT

    DEDENT          shift and go to state 50


state 43

    (6) piece_expr -> piece_expr STRING NUMBER NEWLINE .

    DEDENT          reduce using rule 6 (piece_expr -> piece_expr STRING NUMBER NEWLINE .)
    STRING          reduce using rule 6 (piece_expr -> piece_expr STRING NUMBER NEWLINE .)


state 44

    (8) player_stmt -> PLAYER : NEWLINE INDENT NUMBER NEWLINE DEDENT .

    RULE            reduce using rule 8 (player_stmt -> PLAYER : NEWLINE INDENT NUMBER NEWLINE DEDENT .)


state 45

    (10) action_stmt -> ACTION : . = ID NEWLINE

    =               shift and go to state 51


state 46

    (9) rule_stmt -> RULE : NEWLINE INDENT action_stmt DEDENT .

    FUNCTION        reduce using rule 9 (rule_stmt -> RULE : NEWLINE INDENT action_stmt DEDENT .)


state 47

    (11) action_stmt -> action_stmt ACTION . : = ID NEWLINE

    :               shift and go to state 52


state 48

    (27) global_assign_stmt -> empty .

    GLOBAL          reduce using rule 27 (global_assign_stmt -> empty .)
    DEF             reduce using rule 27 (global_assign_stmt -> empty .)


state 49

    (12) function_stmt -> FUNCTION : NEWLINE INDENT global_assign_stmt . funcdef DEDENT
    (13) function_stmt -> FUNCTION : NEWLINE INDENT global_assign_stmt . init_assign_stmt funcdef DEDENT
    (26) global_assign_stmt -> global_assign_stmt . GLOBAL assign_stmt
    (31) funcdef -> . DEF ID parameters : suite
    (32) funcdef -> . DEF ID : suite
    (33) funcdef -> . funcdef DEF ID parameters : suite
    (34) funcdef -> . funcdef DEF ID : suite
    (23) init_assign_stmt -> . DEF INIT : NEWLINE INDENT init_stmt DEDENT

    GLOBAL          shift and go to state 53
    DEF             shift and go to state 54

    init_assign_stmt               shift and go to state 55
    funcdef                        shift and go to state 56

state 50

    (7) board_stmt -> BOARD : NEWLINE INDENT NUMBER NUMBER NEWLINE DEDENT .

    PLAYER          reduce using rule 7 (board_stmt -> BOARD : NEWLINE INDENT NUMBER NUMBER NEWLINE DEDENT .)


state 51

    (10) action_stmt -> ACTION : = . ID NEWLINE

    ID              shift and go to state 57


state 52

    (11) action_stmt -> action_stmt ACTION : . = ID NEWLINE

    =               shift and go to state 58


state 53

    (26) global_assign_stmt -> global_assign_stmt GLOBAL . assign_stmt
    (22) assign_stmt -> . power : = expr NEWLINE
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    power                          shift and go to state 65
    assign_stmt                    shift and go to state 63
    atom                           shift and go to state 66
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 54

    (31) funcdef -> DEF . ID parameters : suite
    (32) funcdef -> DEF . ID : suite
    (23) init_assign_stmt -> DEF . INIT : NEWLINE INDENT init_stmt DEDENT

    ID              shift and go to state 73
    INIT            shift and go to state 72


state 55

    (13) function_stmt -> FUNCTION : NEWLINE INDENT global_assign_stmt init_assign_stmt . funcdef DEDENT
    (31) funcdef -> . DEF ID parameters : suite
    (32) funcdef -> . DEF ID : suite
    (33) funcdef -> . funcdef DEF ID parameters : suite
    (34) funcdef -> . funcdef DEF ID : suite

    DEF             shift and go to state 74

    funcdef                        shift and go to state 75

state 56

    (12) function_stmt -> FUNCTION : NEWLINE INDENT global_assign_stmt funcdef . DEDENT
    (33) funcdef -> funcdef . DEF ID parameters : suite
    (34) funcdef -> funcdef . DEF ID : suite

    DEDENT          shift and go to state 76
    DEF             shift and go to state 77


state 57

    (10) action_stmt -> ACTION : = ID . NEWLINE

    NEWLINE         shift and go to state 78


state 58

    (11) action_stmt -> action_stmt ACTION : = . ID NEWLINE

    ID              shift and go to state 79


state 59

    (68) atom -> NUMBER .

    .               reduce using rule 68 (atom -> NUMBER .)
    [               reduce using rule 68 (atom -> NUMBER .)
    *               reduce using rule 68 (atom -> NUMBER .)
    /               reduce using rule 68 (atom -> NUMBER .)
    %               reduce using rule 68 (atom -> NUMBER .)
    +               reduce using rule 68 (atom -> NUMBER .)
    -               reduce using rule 68 (atom -> NUMBER .)
    =               reduce using rule 68 (atom -> NUMBER .)
    >               reduce using rule 68 (atom -> NUMBER .)
    <               reduce using rule 68 (atom -> NUMBER .)
    ~               reduce using rule 68 (atom -> NUMBER .)
    AND             reduce using rule 68 (atom -> NUMBER .)
    OR              reduce using rule 68 (atom -> NUMBER .)
    )               reduce using rule 68 (atom -> NUMBER .)
    ,               reduce using rule 68 (atom -> NUMBER .)
    ]               reduce using rule 68 (atom -> NUMBER .)
    NEWLINE         reduce using rule 68 (atom -> NUMBER .)
    :               reduce using rule 68 (atom -> NUMBER .)


state 60

    (64) atom -> array .

    .               reduce using rule 64 (atom -> array .)
    [               reduce using rule 64 (atom -> array .)
    *               reduce using rule 64 (atom -> array .)
    /               reduce using rule 64 (atom -> array .)
    %               reduce using rule 64 (atom -> array .)
    +               reduce using rule 64 (atom -> array .)
    -               reduce using rule 64 (atom -> array .)
    =               reduce using rule 64 (atom -> array .)
    >               reduce using rule 64 (atom -> array .)
    <               reduce using rule 64 (atom -> array .)
    ~               reduce using rule 64 (atom -> array .)
    AND             reduce using rule 64 (atom -> array .)
    OR              reduce using rule 64 (atom -> array .)
    )               reduce using rule 64 (atom -> array .)
    ,               reduce using rule 64 (atom -> array .)
    ]               reduce using rule 64 (atom -> array .)
    NEWLINE         reduce using rule 64 (atom -> array .)
    :               reduce using rule 64 (atom -> array .)


state 61

    (71) atom -> func_expr .

    .               reduce using rule 71 (atom -> func_expr .)
    [               reduce using rule 71 (atom -> func_expr .)
    *               reduce using rule 71 (atom -> func_expr .)
    /               reduce using rule 71 (atom -> func_expr .)
    %               reduce using rule 71 (atom -> func_expr .)
    +               reduce using rule 71 (atom -> func_expr .)
    -               reduce using rule 71 (atom -> func_expr .)
    =               reduce using rule 71 (atom -> func_expr .)
    >               reduce using rule 71 (atom -> func_expr .)
    <               reduce using rule 71 (atom -> func_expr .)
    ~               reduce using rule 71 (atom -> func_expr .)
    AND             reduce using rule 71 (atom -> func_expr .)
    OR              reduce using rule 71 (atom -> func_expr .)
    )               reduce using rule 71 (atom -> func_expr .)
    ,               reduce using rule 71 (atom -> func_expr .)
    ]               reduce using rule 71 (atom -> func_expr .)
    NEWLINE         reduce using rule 71 (atom -> func_expr .)
    :               reduce using rule 71 (atom -> func_expr .)


state 62

    (72) atom -> ( . expr )
    (73) position -> ( . expr , expr )
    (38) expr -> . or_test
    (39) or_test -> . and_test
    (40) or_test -> . or_test OR and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    power                          shift and go to state 85
    expr                           shift and go to state 89
    atom                           shift and go to state 66
    or_test                        shift and go to state 90
    and_test                       shift and go to state 86
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 63

    (26) global_assign_stmt -> global_assign_stmt GLOBAL assign_stmt .

    GLOBAL          reduce using rule 26 (global_assign_stmt -> global_assign_stmt GLOBAL assign_stmt .)
    DEF             reduce using rule 26 (global_assign_stmt -> global_assign_stmt GLOBAL assign_stmt .)


state 64

    (67) atom -> STRING .

    .               reduce using rule 67 (atom -> STRING .)
    [               reduce using rule 67 (atom -> STRING .)
    *               reduce using rule 67 (atom -> STRING .)
    /               reduce using rule 67 (atom -> STRING .)
    %               reduce using rule 67 (atom -> STRING .)
    +               reduce using rule 67 (atom -> STRING .)
    -               reduce using rule 67 (atom -> STRING .)
    =               reduce using rule 67 (atom -> STRING .)
    >               reduce using rule 67 (atom -> STRING .)
    <               reduce using rule 67 (atom -> STRING .)
    ~               reduce using rule 67 (atom -> STRING .)
    AND             reduce using rule 67 (atom -> STRING .)
    OR              reduce using rule 67 (atom -> STRING .)
    )               reduce using rule 67 (atom -> STRING .)
    ,               reduce using rule 67 (atom -> STRING .)
    ]               reduce using rule 67 (atom -> STRING .)
    NEWLINE         reduce using rule 67 (atom -> STRING .)
    :               reduce using rule 67 (atom -> STRING .)


state 65

    (22) assign_stmt -> power . : = expr NEWLINE
    (63) power -> power . trailer
    (75) trailer -> . . ID
    (76) trailer -> . [ expr ]

    :               shift and go to state 94
    .               shift and go to state 92
    [               shift and go to state 93

    trailer                        shift and go to state 95

state 66

    (62) power -> atom .

    .               reduce using rule 62 (power -> atom .)
    [               reduce using rule 62 (power -> atom .)
    *               reduce using rule 62 (power -> atom .)
    /               reduce using rule 62 (power -> atom .)
    %               reduce using rule 62 (power -> atom .)
    +               reduce using rule 62 (power -> atom .)
    -               reduce using rule 62 (power -> atom .)
    =               reduce using rule 62 (power -> atom .)
    >               reduce using rule 62 (power -> atom .)
    <               reduce using rule 62 (power -> atom .)
    ~               reduce using rule 62 (power -> atom .)
    AND             reduce using rule 62 (power -> atom .)
    OR              reduce using rule 62 (power -> atom .)
    )               reduce using rule 62 (power -> atom .)
    ,               reduce using rule 62 (power -> atom .)
    ]               reduce using rule 62 (power -> atom .)
    NEWLINE         reduce using rule 62 (power -> atom .)
    :               reduce using rule 62 (power -> atom .)


state 67

    (74) array -> [ . parameter_list ]
    (79) parameter_list -> . expr
    (80) parameter_list -> . parameter_list , expr
    (38) expr -> . or_test
    (39) or_test -> . and_test
    (40) or_test -> . or_test OR and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    power                          shift and go to state 85
    parameter_list                 shift and go to state 96
    expr                           shift and go to state 97
    atom                           shift and go to state 66
    or_test                        shift and go to state 90
    and_test                       shift and go to state 86
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 68

    (66) atom -> ID .
    (77) func_expr -> ID . ( )
    (78) func_expr -> ID . ( parameter_list )

    .               reduce using rule 66 (atom -> ID .)
    [               reduce using rule 66 (atom -> ID .)
    *               reduce using rule 66 (atom -> ID .)
    /               reduce using rule 66 (atom -> ID .)
    %               reduce using rule 66 (atom -> ID .)
    +               reduce using rule 66 (atom -> ID .)
    -               reduce using rule 66 (atom -> ID .)
    =               reduce using rule 66 (atom -> ID .)
    >               reduce using rule 66 (atom -> ID .)
    <               reduce using rule 66 (atom -> ID .)
    ~               reduce using rule 66 (atom -> ID .)
    AND             reduce using rule 66 (atom -> ID .)
    OR              reduce using rule 66 (atom -> ID .)
    )               reduce using rule 66 (atom -> ID .)
    ,               reduce using rule 66 (atom -> ID .)
    ]               reduce using rule 66 (atom -> ID .)
    NEWLINE         reduce using rule 66 (atom -> ID .)
    :               reduce using rule 66 (atom -> ID .)
    (               shift and go to state 98


state 69

    (70) atom -> NIL .

    .               reduce using rule 70 (atom -> NIL .)
    [               reduce using rule 70 (atom -> NIL .)
    *               reduce using rule 70 (atom -> NIL .)
    /               reduce using rule 70 (atom -> NIL .)
    %               reduce using rule 70 (atom -> NIL .)
    +               reduce using rule 70 (atom -> NIL .)
    -               reduce using rule 70 (atom -> NIL .)
    =               reduce using rule 70 (atom -> NIL .)
    >               reduce using rule 70 (atom -> NIL .)
    <               reduce using rule 70 (atom -> NIL .)
    ~               reduce using rule 70 (atom -> NIL .)
    AND             reduce using rule 70 (atom -> NIL .)
    OR              reduce using rule 70 (atom -> NIL .)
    )               reduce using rule 70 (atom -> NIL .)
    ,               reduce using rule 70 (atom -> NIL .)
    ]               reduce using rule 70 (atom -> NIL .)
    NEWLINE         reduce using rule 70 (atom -> NIL .)
    :               reduce using rule 70 (atom -> NIL .)


state 70

    (69) atom -> BOOLEAN .

    .               reduce using rule 69 (atom -> BOOLEAN .)
    [               reduce using rule 69 (atom -> BOOLEAN .)
    *               reduce using rule 69 (atom -> BOOLEAN .)
    /               reduce using rule 69 (atom -> BOOLEAN .)
    %               reduce using rule 69 (atom -> BOOLEAN .)
    +               reduce using rule 69 (atom -> BOOLEAN .)
    -               reduce using rule 69 (atom -> BOOLEAN .)
    =               reduce using rule 69 (atom -> BOOLEAN .)
    >               reduce using rule 69 (atom -> BOOLEAN .)
    <               reduce using rule 69 (atom -> BOOLEAN .)
    ~               reduce using rule 69 (atom -> BOOLEAN .)
    AND             reduce using rule 69 (atom -> BOOLEAN .)
    OR              reduce using rule 69 (atom -> BOOLEAN .)
    )               reduce using rule 69 (atom -> BOOLEAN .)
    ,               reduce using rule 69 (atom -> BOOLEAN .)
    ]               reduce using rule 69 (atom -> BOOLEAN .)
    NEWLINE         reduce using rule 69 (atom -> BOOLEAN .)
    :               reduce using rule 69 (atom -> BOOLEAN .)


state 71

    (65) atom -> position .

    .               reduce using rule 65 (atom -> position .)
    [               reduce using rule 65 (atom -> position .)
    *               reduce using rule 65 (atom -> position .)
    /               reduce using rule 65 (atom -> position .)
    %               reduce using rule 65 (atom -> position .)
    +               reduce using rule 65 (atom -> position .)
    -               reduce using rule 65 (atom -> position .)
    =               reduce using rule 65 (atom -> position .)
    >               reduce using rule 65 (atom -> position .)
    <               reduce using rule 65 (atom -> position .)
    ~               reduce using rule 65 (atom -> position .)
    AND             reduce using rule 65 (atom -> position .)
    OR              reduce using rule 65 (atom -> position .)
    )               reduce using rule 65 (atom -> position .)
    ,               reduce using rule 65 (atom -> position .)
    ]               reduce using rule 65 (atom -> position .)
    NEWLINE         reduce using rule 65 (atom -> position .)
    :               reduce using rule 65 (atom -> position .)


state 72

    (23) init_assign_stmt -> DEF INIT . : NEWLINE INDENT init_stmt DEDENT

    :               shift and go to state 99


state 73

    (31) funcdef -> DEF ID . parameters : suite
    (32) funcdef -> DEF ID . : suite
    (35) parameters -> . parameters , parameter
    (36) parameters -> . parameter
    (37) parameter -> . ID

    :               shift and go to state 101
    ID              shift and go to state 103

    parameter                      shift and go to state 102
    parameters                     shift and go to state 100

state 74

    (31) funcdef -> DEF . ID parameters : suite
    (32) funcdef -> DEF . ID : suite

    ID              shift and go to state 73


state 75

    (13) function_stmt -> FUNCTION : NEWLINE INDENT global_assign_stmt init_assign_stmt funcdef . DEDENT
    (33) funcdef -> funcdef . DEF ID parameters : suite
    (34) funcdef -> funcdef . DEF ID : suite

    DEDENT          shift and go to state 104
    DEF             shift and go to state 77


state 76

    (12) function_stmt -> FUNCTION : NEWLINE INDENT global_assign_stmt funcdef DEDENT .

    $end            reduce using rule 12 (function_stmt -> FUNCTION : NEWLINE INDENT global_assign_stmt funcdef DEDENT .)


state 77

    (33) funcdef -> funcdef DEF . ID parameters : suite
    (34) funcdef -> funcdef DEF . ID : suite

    ID              shift and go to state 105


state 78

    (10) action_stmt -> ACTION : = ID NEWLINE .

    DEDENT          reduce using rule 10 (action_stmt -> ACTION : = ID NEWLINE .)
    ACTION          reduce using rule 10 (action_stmt -> ACTION : = ID NEWLINE .)


state 79

    (11) action_stmt -> action_stmt ACTION : = ID . NEWLINE

    NEWLINE         shift and go to state 106


state 80

    (41) and_test -> not_test .

    AND             reduce using rule 41 (and_test -> not_test .)
    OR              reduce using rule 41 (and_test -> not_test .)
    )               reduce using rule 41 (and_test -> not_test .)
    NEWLINE         reduce using rule 41 (and_test -> not_test .)
    ]               reduce using rule 41 (and_test -> not_test .)
    ,               reduce using rule 41 (and_test -> not_test .)
    :               reduce using rule 41 (and_test -> not_test .)


state 81

    (45) comparison -> operand .
    (53) operand -> operand . + term
    (54) operand -> operand . - term

    =               reduce using rule 45 (comparison -> operand .)
    >               reduce using rule 45 (comparison -> operand .)
    <               reduce using rule 45 (comparison -> operand .)
    ~               reduce using rule 45 (comparison -> operand .)
    AND             reduce using rule 45 (comparison -> operand .)
    OR              reduce using rule 45 (comparison -> operand .)
    )               reduce using rule 45 (comparison -> operand .)
    ,               reduce using rule 45 (comparison -> operand .)
    ]               reduce using rule 45 (comparison -> operand .)
    NEWLINE         reduce using rule 45 (comparison -> operand .)
    :               reduce using rule 45 (comparison -> operand .)
    +               shift and go to state 107
    -               shift and go to state 108


state 82

    (60) factor -> + . factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    power                          shift and go to state 85
    factor                         shift and go to state 109
    atom                           shift and go to state 66
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 83

    (61) factor -> - . factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    power                          shift and go to state 85
    factor                         shift and go to state 110
    atom                           shift and go to state 66
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 84

    (55) term -> factor .

    *               reduce using rule 55 (term -> factor .)
    /               reduce using rule 55 (term -> factor .)
    %               reduce using rule 55 (term -> factor .)
    +               reduce using rule 55 (term -> factor .)
    -               reduce using rule 55 (term -> factor .)
    =               reduce using rule 55 (term -> factor .)
    >               reduce using rule 55 (term -> factor .)
    <               reduce using rule 55 (term -> factor .)
    ~               reduce using rule 55 (term -> factor .)
    AND             reduce using rule 55 (term -> factor .)
    OR              reduce using rule 55 (term -> factor .)
    :               reduce using rule 55 (term -> factor .)
    ]               reduce using rule 55 (term -> factor .)
    ,               reduce using rule 55 (term -> factor .)
    )               reduce using rule 55 (term -> factor .)
    NEWLINE         reduce using rule 55 (term -> factor .)


state 85

    (59) factor -> power .
    (63) power -> power . trailer
    (75) trailer -> . . ID
    (76) trailer -> . [ expr ]

    *               reduce using rule 59 (factor -> power .)
    /               reduce using rule 59 (factor -> power .)
    %               reduce using rule 59 (factor -> power .)
    +               reduce using rule 59 (factor -> power .)
    -               reduce using rule 59 (factor -> power .)
    =               reduce using rule 59 (factor -> power .)
    >               reduce using rule 59 (factor -> power .)
    <               reduce using rule 59 (factor -> power .)
    ~               reduce using rule 59 (factor -> power .)
    AND             reduce using rule 59 (factor -> power .)
    OR              reduce using rule 59 (factor -> power .)
    )               reduce using rule 59 (factor -> power .)
    ,               reduce using rule 59 (factor -> power .)
    ]               reduce using rule 59 (factor -> power .)
    NEWLINE         reduce using rule 59 (factor -> power .)
    :               reduce using rule 59 (factor -> power .)
    .               shift and go to state 92
    [               shift and go to state 93

    trailer                        shift and go to state 95

state 86

    (39) or_test -> and_test .
    (42) and_test -> and_test . AND not_test

    OR              reduce using rule 39 (or_test -> and_test .)
    NEWLINE         reduce using rule 39 (or_test -> and_test .)
    :               reduce using rule 39 (or_test -> and_test .)
    ]               reduce using rule 39 (or_test -> and_test .)
    ,               reduce using rule 39 (or_test -> and_test .)
    )               reduce using rule 39 (or_test -> and_test .)
    AND             shift and go to state 111


state 87

    (44) not_test -> comparison .
    (46) comparison -> comparison . = operand
    (47) comparison -> comparison . > operand
    (48) comparison -> comparison . < operand
    (49) comparison -> comparison . > = operand
    (50) comparison -> comparison . < = operand
    (51) comparison -> comparison . ~ = operand

    AND             reduce using rule 44 (not_test -> comparison .)
    OR              reduce using rule 44 (not_test -> comparison .)
    )               reduce using rule 44 (not_test -> comparison .)
    ,               reduce using rule 44 (not_test -> comparison .)
    ]               reduce using rule 44 (not_test -> comparison .)
    NEWLINE         reduce using rule 44 (not_test -> comparison .)
    :               reduce using rule 44 (not_test -> comparison .)
    =               shift and go to state 113
    >               shift and go to state 112
    <               shift and go to state 114
    ~               shift and go to state 115


state 88

    (52) operand -> term .
    (56) term -> term . * factor
    (57) term -> term . / factor
    (58) term -> term . % factor

    +               reduce using rule 52 (operand -> term .)
    -               reduce using rule 52 (operand -> term .)
    =               reduce using rule 52 (operand -> term .)
    >               reduce using rule 52 (operand -> term .)
    <               reduce using rule 52 (operand -> term .)
    ~               reduce using rule 52 (operand -> term .)
    AND             reduce using rule 52 (operand -> term .)
    OR              reduce using rule 52 (operand -> term .)
    :               reduce using rule 52 (operand -> term .)
    ]               reduce using rule 52 (operand -> term .)
    ,               reduce using rule 52 (operand -> term .)
    )               reduce using rule 52 (operand -> term .)
    NEWLINE         reduce using rule 52 (operand -> term .)
    *               shift and go to state 116
    /               shift and go to state 118
    %               shift and go to state 117


state 89

    (72) atom -> ( expr . )
    (73) position -> ( expr . , expr )

    )               shift and go to state 119
    ,               shift and go to state 120


state 90

    (38) expr -> or_test .
    (40) or_test -> or_test . OR and_test

    ]               reduce using rule 38 (expr -> or_test .)
    ,               reduce using rule 38 (expr -> or_test .)
    )               reduce using rule 38 (expr -> or_test .)
    :               reduce using rule 38 (expr -> or_test .)
    NEWLINE         reduce using rule 38 (expr -> or_test .)
    OR              shift and go to state 121


state 91

    (43) not_test -> NOT . not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    power                          shift and go to state 85
    atom                           shift and go to state 66
    not_test                       shift and go to state 122
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 92

    (75) trailer -> . . ID

    ID              shift and go to state 123


state 93

    (76) trailer -> [ . expr ]
    (38) expr -> . or_test
    (39) or_test -> . and_test
    (40) or_test -> . or_test OR and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    power                          shift and go to state 85
    expr                           shift and go to state 124
    atom                           shift and go to state 66
    or_test                        shift and go to state 90
    and_test                       shift and go to state 86
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 94

    (22) assign_stmt -> power : . = expr NEWLINE

    =               shift and go to state 125


state 95

    (63) power -> power trailer .

    .               reduce using rule 63 (power -> power trailer .)
    [               reduce using rule 63 (power -> power trailer .)
    *               reduce using rule 63 (power -> power trailer .)
    /               reduce using rule 63 (power -> power trailer .)
    %               reduce using rule 63 (power -> power trailer .)
    +               reduce using rule 63 (power -> power trailer .)
    -               reduce using rule 63 (power -> power trailer .)
    =               reduce using rule 63 (power -> power trailer .)
    >               reduce using rule 63 (power -> power trailer .)
    <               reduce using rule 63 (power -> power trailer .)
    ~               reduce using rule 63 (power -> power trailer .)
    AND             reduce using rule 63 (power -> power trailer .)
    OR              reduce using rule 63 (power -> power trailer .)
    )               reduce using rule 63 (power -> power trailer .)
    ,               reduce using rule 63 (power -> power trailer .)
    ]               reduce using rule 63 (power -> power trailer .)
    NEWLINE         reduce using rule 63 (power -> power trailer .)
    :               reduce using rule 63 (power -> power trailer .)


state 96

    (74) array -> [ parameter_list . ]
    (80) parameter_list -> parameter_list . , expr

    ]               shift and go to state 126
    ,               shift and go to state 127


state 97

    (79) parameter_list -> expr .

    ]               reduce using rule 79 (parameter_list -> expr .)
    ,               reduce using rule 79 (parameter_list -> expr .)
    )               reduce using rule 79 (parameter_list -> expr .)


state 98

    (77) func_expr -> ID ( . )
    (78) func_expr -> ID ( . parameter_list )
    (79) parameter_list -> . expr
    (80) parameter_list -> . parameter_list , expr
    (38) expr -> . or_test
    (39) or_test -> . and_test
    (40) or_test -> . or_test OR and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    )               shift and go to state 128
    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    power                          shift and go to state 85
    parameter_list                 shift and go to state 129
    expr                           shift and go to state 97
    atom                           shift and go to state 66
    or_test                        shift and go to state 90
    and_test                       shift and go to state 86
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 99

    (23) init_assign_stmt -> DEF INIT : . NEWLINE INDENT init_stmt DEDENT

    NEWLINE         shift and go to state 130


state 100

    (31) funcdef -> DEF ID parameters . : suite
    (35) parameters -> parameters . , parameter

    :               shift and go to state 132
    ,               shift and go to state 131


state 101

    (32) funcdef -> DEF ID : . suite
    (90) suite -> . NEWLINE
    (91) suite -> . NEWLINE INDENT suite_stmt DEDENT

    NEWLINE         shift and go to state 133

    suite                          shift and go to state 134

state 102

    (36) parameters -> parameter .

    :               reduce using rule 36 (parameters -> parameter .)
    ,               reduce using rule 36 (parameters -> parameter .)


state 103

    (37) parameter -> ID .

    :               reduce using rule 37 (parameter -> ID .)
    ,               reduce using rule 37 (parameter -> ID .)


state 104

    (13) function_stmt -> FUNCTION : NEWLINE INDENT global_assign_stmt init_assign_stmt funcdef DEDENT .

    $end            reduce using rule 13 (function_stmt -> FUNCTION : NEWLINE INDENT global_assign_stmt init_assign_stmt funcdef DEDENT .)


state 105

    (33) funcdef -> funcdef DEF ID . parameters : suite
    (34) funcdef -> funcdef DEF ID . : suite
    (35) parameters -> . parameters , parameter
    (36) parameters -> . parameter
    (37) parameter -> . ID

    :               shift and go to state 136
    ID              shift and go to state 103

    parameter                      shift and go to state 102
    parameters                     shift and go to state 135

state 106

    (11) action_stmt -> action_stmt ACTION : = ID NEWLINE .

    DEDENT          reduce using rule 11 (action_stmt -> action_stmt ACTION : = ID NEWLINE .)
    ACTION          reduce using rule 11 (action_stmt -> action_stmt ACTION : = ID NEWLINE .)


state 107

    (53) operand -> operand + . term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    term                           shift and go to state 137
    power                          shift and go to state 85
    factor                         shift and go to state 84
    atom                           shift and go to state 66
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 108

    (54) operand -> operand - . term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    term                           shift and go to state 138
    power                          shift and go to state 85
    factor                         shift and go to state 84
    atom                           shift and go to state 66
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 109

    (60) factor -> + factor .

    *               reduce using rule 60 (factor -> + factor .)
    /               reduce using rule 60 (factor -> + factor .)
    %               reduce using rule 60 (factor -> + factor .)
    +               reduce using rule 60 (factor -> + factor .)
    -               reduce using rule 60 (factor -> + factor .)
    =               reduce using rule 60 (factor -> + factor .)
    >               reduce using rule 60 (factor -> + factor .)
    <               reduce using rule 60 (factor -> + factor .)
    ~               reduce using rule 60 (factor -> + factor .)
    AND             reduce using rule 60 (factor -> + factor .)
    OR              reduce using rule 60 (factor -> + factor .)
    )               reduce using rule 60 (factor -> + factor .)
    ,               reduce using rule 60 (factor -> + factor .)
    ]               reduce using rule 60 (factor -> + factor .)
    NEWLINE         reduce using rule 60 (factor -> + factor .)
    :               reduce using rule 60 (factor -> + factor .)


state 110

    (61) factor -> - factor .

    *               reduce using rule 61 (factor -> - factor .)
    /               reduce using rule 61 (factor -> - factor .)
    %               reduce using rule 61 (factor -> - factor .)
    +               reduce using rule 61 (factor -> - factor .)
    -               reduce using rule 61 (factor -> - factor .)
    =               reduce using rule 61 (factor -> - factor .)
    >               reduce using rule 61 (factor -> - factor .)
    <               reduce using rule 61 (factor -> - factor .)
    ~               reduce using rule 61 (factor -> - factor .)
    AND             reduce using rule 61 (factor -> - factor .)
    OR              reduce using rule 61 (factor -> - factor .)
    )               reduce using rule 61 (factor -> - factor .)
    ,               reduce using rule 61 (factor -> - factor .)
    ]               reduce using rule 61 (factor -> - factor .)
    NEWLINE         reduce using rule 61 (factor -> - factor .)
    :               reduce using rule 61 (factor -> - factor .)


state 111

    (42) and_test -> and_test AND . not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    power                          shift and go to state 85
    atom                           shift and go to state 66
    not_test                       shift and go to state 139
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 112

    (47) comparison -> comparison > . operand
    (49) comparison -> comparison > . = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    =               shift and go to state 141
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    term                           shift and go to state 88
    power                          shift and go to state 85
    factor                         shift and go to state 84
    atom                           shift and go to state 66
    operand                        shift and go to state 140
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 113

    (46) comparison -> comparison = . operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    term                           shift and go to state 88
    power                          shift and go to state 85
    factor                         shift and go to state 84
    atom                           shift and go to state 66
    operand                        shift and go to state 142
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 114

    (48) comparison -> comparison < . operand
    (50) comparison -> comparison < . = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    =               shift and go to state 144
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    term                           shift and go to state 88
    power                          shift and go to state 85
    factor                         shift and go to state 84
    atom                           shift and go to state 66
    operand                        shift and go to state 143
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 115

    (51) comparison -> comparison ~ . = operand

    =               shift and go to state 145


state 116

    (56) term -> term * . factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    power                          shift and go to state 85
    factor                         shift and go to state 146
    atom                           shift and go to state 66
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 117

    (58) term -> term % . factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    power                          shift and go to state 85
    factor                         shift and go to state 147
    atom                           shift and go to state 66
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 118

    (57) term -> term / . factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    power                          shift and go to state 85
    factor                         shift and go to state 148
    atom                           shift and go to state 66
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 119

    (72) atom -> ( expr ) .

    .               reduce using rule 72 (atom -> ( expr ) .)
    [               reduce using rule 72 (atom -> ( expr ) .)
    *               reduce using rule 72 (atom -> ( expr ) .)
    /               reduce using rule 72 (atom -> ( expr ) .)
    %               reduce using rule 72 (atom -> ( expr ) .)
    +               reduce using rule 72 (atom -> ( expr ) .)
    -               reduce using rule 72 (atom -> ( expr ) .)
    =               reduce using rule 72 (atom -> ( expr ) .)
    >               reduce using rule 72 (atom -> ( expr ) .)
    <               reduce using rule 72 (atom -> ( expr ) .)
    ~               reduce using rule 72 (atom -> ( expr ) .)
    AND             reduce using rule 72 (atom -> ( expr ) .)
    OR              reduce using rule 72 (atom -> ( expr ) .)
    )               reduce using rule 72 (atom -> ( expr ) .)
    ,               reduce using rule 72 (atom -> ( expr ) .)
    ]               reduce using rule 72 (atom -> ( expr ) .)
    NEWLINE         reduce using rule 72 (atom -> ( expr ) .)
    :               reduce using rule 72 (atom -> ( expr ) .)


state 120

    (73) position -> ( expr , . expr )
    (38) expr -> . or_test
    (39) or_test -> . and_test
    (40) or_test -> . or_test OR and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    power                          shift and go to state 85
    expr                           shift and go to state 149
    atom                           shift and go to state 66
    or_test                        shift and go to state 90
    and_test                       shift and go to state 86
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 121

    (40) or_test -> or_test OR . and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    power                          shift and go to state 85
    atom                           shift and go to state 66
    and_test                       shift and go to state 150
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 122

    (43) not_test -> NOT not_test .

    AND             reduce using rule 43 (not_test -> NOT not_test .)
    OR              reduce using rule 43 (not_test -> NOT not_test .)
    )               reduce using rule 43 (not_test -> NOT not_test .)
    ,               reduce using rule 43 (not_test -> NOT not_test .)
    ]               reduce using rule 43 (not_test -> NOT not_test .)
    NEWLINE         reduce using rule 43 (not_test -> NOT not_test .)
    :               reduce using rule 43 (not_test -> NOT not_test .)


state 123

    (75) trailer -> . ID .

    .               reduce using rule 75 (trailer -> . ID .)
    [               reduce using rule 75 (trailer -> . ID .)
    *               reduce using rule 75 (trailer -> . ID .)
    /               reduce using rule 75 (trailer -> . ID .)
    %               reduce using rule 75 (trailer -> . ID .)
    +               reduce using rule 75 (trailer -> . ID .)
    -               reduce using rule 75 (trailer -> . ID .)
    =               reduce using rule 75 (trailer -> . ID .)
    >               reduce using rule 75 (trailer -> . ID .)
    <               reduce using rule 75 (trailer -> . ID .)
    ~               reduce using rule 75 (trailer -> . ID .)
    AND             reduce using rule 75 (trailer -> . ID .)
    OR              reduce using rule 75 (trailer -> . ID .)
    )               reduce using rule 75 (trailer -> . ID .)
    ,               reduce using rule 75 (trailer -> . ID .)
    ]               reduce using rule 75 (trailer -> . ID .)
    NEWLINE         reduce using rule 75 (trailer -> . ID .)
    :               reduce using rule 75 (trailer -> . ID .)


state 124

    (76) trailer -> [ expr . ]

    ]               shift and go to state 151


state 125

    (22) assign_stmt -> power : = . expr NEWLINE
    (38) expr -> . or_test
    (39) or_test -> . and_test
    (40) or_test -> . or_test OR and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    power                          shift and go to state 85
    expr                           shift and go to state 152
    atom                           shift and go to state 66
    or_test                        shift and go to state 90
    and_test                       shift and go to state 86
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 126

    (74) array -> [ parameter_list ] .

    .               reduce using rule 74 (array -> [ parameter_list ] .)
    [               reduce using rule 74 (array -> [ parameter_list ] .)
    *               reduce using rule 74 (array -> [ parameter_list ] .)
    /               reduce using rule 74 (array -> [ parameter_list ] .)
    %               reduce using rule 74 (array -> [ parameter_list ] .)
    +               reduce using rule 74 (array -> [ parameter_list ] .)
    -               reduce using rule 74 (array -> [ parameter_list ] .)
    =               reduce using rule 74 (array -> [ parameter_list ] .)
    >               reduce using rule 74 (array -> [ parameter_list ] .)
    <               reduce using rule 74 (array -> [ parameter_list ] .)
    ~               reduce using rule 74 (array -> [ parameter_list ] .)
    AND             reduce using rule 74 (array -> [ parameter_list ] .)
    OR              reduce using rule 74 (array -> [ parameter_list ] .)
    )               reduce using rule 74 (array -> [ parameter_list ] .)
    ,               reduce using rule 74 (array -> [ parameter_list ] .)
    ]               reduce using rule 74 (array -> [ parameter_list ] .)
    NEWLINE         reduce using rule 74 (array -> [ parameter_list ] .)
    :               reduce using rule 74 (array -> [ parameter_list ] .)


state 127

    (80) parameter_list -> parameter_list , . expr
    (38) expr -> . or_test
    (39) or_test -> . and_test
    (40) or_test -> . or_test OR and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    power                          shift and go to state 85
    expr                           shift and go to state 153
    atom                           shift and go to state 66
    or_test                        shift and go to state 90
    and_test                       shift and go to state 86
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 128

    (77) func_expr -> ID ( ) .

    .               reduce using rule 77 (func_expr -> ID ( ) .)
    [               reduce using rule 77 (func_expr -> ID ( ) .)
    *               reduce using rule 77 (func_expr -> ID ( ) .)
    /               reduce using rule 77 (func_expr -> ID ( ) .)
    %               reduce using rule 77 (func_expr -> ID ( ) .)
    +               reduce using rule 77 (func_expr -> ID ( ) .)
    -               reduce using rule 77 (func_expr -> ID ( ) .)
    =               reduce using rule 77 (func_expr -> ID ( ) .)
    >               reduce using rule 77 (func_expr -> ID ( ) .)
    <               reduce using rule 77 (func_expr -> ID ( ) .)
    ~               reduce using rule 77 (func_expr -> ID ( ) .)
    AND             reduce using rule 77 (func_expr -> ID ( ) .)
    OR              reduce using rule 77 (func_expr -> ID ( ) .)
    )               reduce using rule 77 (func_expr -> ID ( ) .)
    ,               reduce using rule 77 (func_expr -> ID ( ) .)
    ]               reduce using rule 77 (func_expr -> ID ( ) .)
    NEWLINE         reduce using rule 77 (func_expr -> ID ( ) .)
    :               reduce using rule 77 (func_expr -> ID ( ) .)


state 129

    (78) func_expr -> ID ( parameter_list . )
    (80) parameter_list -> parameter_list . , expr

    )               shift and go to state 154
    ,               shift and go to state 127


state 130

    (23) init_assign_stmt -> DEF INIT : NEWLINE . INDENT init_stmt DEDENT

    INDENT          shift and go to state 155


state 131

    (35) parameters -> parameters , . parameter
    (37) parameter -> . ID

    ID              shift and go to state 103

    parameter                      shift and go to state 156

state 132

    (31) funcdef -> DEF ID parameters : . suite
    (90) suite -> . NEWLINE
    (91) suite -> . NEWLINE INDENT suite_stmt DEDENT

    NEWLINE         shift and go to state 133

    suite                          shift and go to state 157

state 133

    (90) suite -> NEWLINE .
    (91) suite -> NEWLINE . INDENT suite_stmt DEDENT

    DEDENT          reduce using rule 90 (suite -> NEWLINE .)
    DEF             reduce using rule 90 (suite -> NEWLINE .)
    ELSE            reduce using rule 90 (suite -> NEWLINE .)
    ELSEIF          reduce using rule 90 (suite -> NEWLINE .)
    ID              reduce using rule 90 (suite -> NEWLINE .)
    FOR             reduce using rule 90 (suite -> NEWLINE .)
    IF              reduce using rule 90 (suite -> NEWLINE .)
    WHILE           reduce using rule 90 (suite -> NEWLINE .)
    BREAK           reduce using rule 90 (suite -> NEWLINE .)
    CONTINUE        reduce using rule 90 (suite -> NEWLINE .)
    RETURN          reduce using rule 90 (suite -> NEWLINE .)
    STRING          reduce using rule 90 (suite -> NEWLINE .)
    NUMBER          reduce using rule 90 (suite -> NEWLINE .)
    BOOLEAN         reduce using rule 90 (suite -> NEWLINE .)
    NIL             reduce using rule 90 (suite -> NEWLINE .)
    (               reduce using rule 90 (suite -> NEWLINE .)
    [               reduce using rule 90 (suite -> NEWLINE .)
    INDENT          shift and go to state 158


state 134

    (32) funcdef -> DEF ID : suite .

    DEDENT          reduce using rule 32 (funcdef -> DEF ID : suite .)
    DEF             reduce using rule 32 (funcdef -> DEF ID : suite .)


state 135

    (33) funcdef -> funcdef DEF ID parameters . : suite
    (35) parameters -> parameters . , parameter

    :               shift and go to state 159
    ,               shift and go to state 131


state 136

    (34) funcdef -> funcdef DEF ID : . suite
    (90) suite -> . NEWLINE
    (91) suite -> . NEWLINE INDENT suite_stmt DEDENT

    NEWLINE         shift and go to state 133

    suite                          shift and go to state 160

state 137

    (53) operand -> operand + term .
    (56) term -> term . * factor
    (57) term -> term . / factor
    (58) term -> term . % factor

    +               reduce using rule 53 (operand -> operand + term .)
    -               reduce using rule 53 (operand -> operand + term .)
    =               reduce using rule 53 (operand -> operand + term .)
    >               reduce using rule 53 (operand -> operand + term .)
    <               reduce using rule 53 (operand -> operand + term .)
    ~               reduce using rule 53 (operand -> operand + term .)
    AND             reduce using rule 53 (operand -> operand + term .)
    OR              reduce using rule 53 (operand -> operand + term .)
    :               reduce using rule 53 (operand -> operand + term .)
    ]               reduce using rule 53 (operand -> operand + term .)
    ,               reduce using rule 53 (operand -> operand + term .)
    )               reduce using rule 53 (operand -> operand + term .)
    NEWLINE         reduce using rule 53 (operand -> operand + term .)
    *               shift and go to state 116
    /               shift and go to state 118
    %               shift and go to state 117


state 138

    (54) operand -> operand - term .
    (56) term -> term . * factor
    (57) term -> term . / factor
    (58) term -> term . % factor

    +               reduce using rule 54 (operand -> operand - term .)
    -               reduce using rule 54 (operand -> operand - term .)
    =               reduce using rule 54 (operand -> operand - term .)
    >               reduce using rule 54 (operand -> operand - term .)
    <               reduce using rule 54 (operand -> operand - term .)
    ~               reduce using rule 54 (operand -> operand - term .)
    AND             reduce using rule 54 (operand -> operand - term .)
    OR              reduce using rule 54 (operand -> operand - term .)
    :               reduce using rule 54 (operand -> operand - term .)
    ]               reduce using rule 54 (operand -> operand - term .)
    ,               reduce using rule 54 (operand -> operand - term .)
    )               reduce using rule 54 (operand -> operand - term .)
    NEWLINE         reduce using rule 54 (operand -> operand - term .)
    *               shift and go to state 116
    /               shift and go to state 118
    %               shift and go to state 117


state 139

    (42) and_test -> and_test AND not_test .

    AND             reduce using rule 42 (and_test -> and_test AND not_test .)
    OR              reduce using rule 42 (and_test -> and_test AND not_test .)
    )               reduce using rule 42 (and_test -> and_test AND not_test .)
    NEWLINE         reduce using rule 42 (and_test -> and_test AND not_test .)
    ]               reduce using rule 42 (and_test -> and_test AND not_test .)
    ,               reduce using rule 42 (and_test -> and_test AND not_test .)
    :               reduce using rule 42 (and_test -> and_test AND not_test .)


state 140

    (47) comparison -> comparison > operand .
    (53) operand -> operand . + term
    (54) operand -> operand . - term

    =               reduce using rule 47 (comparison -> comparison > operand .)
    >               reduce using rule 47 (comparison -> comparison > operand .)
    <               reduce using rule 47 (comparison -> comparison > operand .)
    ~               reduce using rule 47 (comparison -> comparison > operand .)
    AND             reduce using rule 47 (comparison -> comparison > operand .)
    OR              reduce using rule 47 (comparison -> comparison > operand .)
    )               reduce using rule 47 (comparison -> comparison > operand .)
    ,               reduce using rule 47 (comparison -> comparison > operand .)
    ]               reduce using rule 47 (comparison -> comparison > operand .)
    NEWLINE         reduce using rule 47 (comparison -> comparison > operand .)
    :               reduce using rule 47 (comparison -> comparison > operand .)
    +               shift and go to state 107
    -               shift and go to state 108


state 141

    (49) comparison -> comparison > = . operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    term                           shift and go to state 88
    power                          shift and go to state 85
    factor                         shift and go to state 84
    atom                           shift and go to state 66
    operand                        shift and go to state 161
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 142

    (46) comparison -> comparison = operand .
    (53) operand -> operand . + term
    (54) operand -> operand . - term

    =               reduce using rule 46 (comparison -> comparison = operand .)
    >               reduce using rule 46 (comparison -> comparison = operand .)
    <               reduce using rule 46 (comparison -> comparison = operand .)
    ~               reduce using rule 46 (comparison -> comparison = operand .)
    AND             reduce using rule 46 (comparison -> comparison = operand .)
    OR              reduce using rule 46 (comparison -> comparison = operand .)
    )               reduce using rule 46 (comparison -> comparison = operand .)
    ,               reduce using rule 46 (comparison -> comparison = operand .)
    ]               reduce using rule 46 (comparison -> comparison = operand .)
    NEWLINE         reduce using rule 46 (comparison -> comparison = operand .)
    :               reduce using rule 46 (comparison -> comparison = operand .)
    +               shift and go to state 107
    -               shift and go to state 108


state 143

    (48) comparison -> comparison < operand .
    (53) operand -> operand . + term
    (54) operand -> operand . - term

    =               reduce using rule 48 (comparison -> comparison < operand .)
    >               reduce using rule 48 (comparison -> comparison < operand .)
    <               reduce using rule 48 (comparison -> comparison < operand .)
    ~               reduce using rule 48 (comparison -> comparison < operand .)
    AND             reduce using rule 48 (comparison -> comparison < operand .)
    OR              reduce using rule 48 (comparison -> comparison < operand .)
    )               reduce using rule 48 (comparison -> comparison < operand .)
    ,               reduce using rule 48 (comparison -> comparison < operand .)
    ]               reduce using rule 48 (comparison -> comparison < operand .)
    NEWLINE         reduce using rule 48 (comparison -> comparison < operand .)
    :               reduce using rule 48 (comparison -> comparison < operand .)
    +               shift and go to state 107
    -               shift and go to state 108


state 144

    (50) comparison -> comparison < = . operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    term                           shift and go to state 88
    power                          shift and go to state 85
    factor                         shift and go to state 84
    atom                           shift and go to state 66
    operand                        shift and go to state 162
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 145

    (51) comparison -> comparison ~ = . operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    term                           shift and go to state 88
    power                          shift and go to state 85
    factor                         shift and go to state 84
    atom                           shift and go to state 66
    operand                        shift and go to state 163
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 146

    (56) term -> term * factor .

    *               reduce using rule 56 (term -> term * factor .)
    /               reduce using rule 56 (term -> term * factor .)
    %               reduce using rule 56 (term -> term * factor .)
    +               reduce using rule 56 (term -> term * factor .)
    -               reduce using rule 56 (term -> term * factor .)
    =               reduce using rule 56 (term -> term * factor .)
    >               reduce using rule 56 (term -> term * factor .)
    <               reduce using rule 56 (term -> term * factor .)
    ~               reduce using rule 56 (term -> term * factor .)
    AND             reduce using rule 56 (term -> term * factor .)
    OR              reduce using rule 56 (term -> term * factor .)
    :               reduce using rule 56 (term -> term * factor .)
    ]               reduce using rule 56 (term -> term * factor .)
    ,               reduce using rule 56 (term -> term * factor .)
    )               reduce using rule 56 (term -> term * factor .)
    NEWLINE         reduce using rule 56 (term -> term * factor .)


state 147

    (58) term -> term % factor .

    *               reduce using rule 58 (term -> term % factor .)
    /               reduce using rule 58 (term -> term % factor .)
    %               reduce using rule 58 (term -> term % factor .)
    +               reduce using rule 58 (term -> term % factor .)
    -               reduce using rule 58 (term -> term % factor .)
    =               reduce using rule 58 (term -> term % factor .)
    >               reduce using rule 58 (term -> term % factor .)
    <               reduce using rule 58 (term -> term % factor .)
    ~               reduce using rule 58 (term -> term % factor .)
    AND             reduce using rule 58 (term -> term % factor .)
    OR              reduce using rule 58 (term -> term % factor .)
    :               reduce using rule 58 (term -> term % factor .)
    ]               reduce using rule 58 (term -> term % factor .)
    ,               reduce using rule 58 (term -> term % factor .)
    )               reduce using rule 58 (term -> term % factor .)
    NEWLINE         reduce using rule 58 (term -> term % factor .)


state 148

    (57) term -> term / factor .

    *               reduce using rule 57 (term -> term / factor .)
    /               reduce using rule 57 (term -> term / factor .)
    %               reduce using rule 57 (term -> term / factor .)
    +               reduce using rule 57 (term -> term / factor .)
    -               reduce using rule 57 (term -> term / factor .)
    =               reduce using rule 57 (term -> term / factor .)
    >               reduce using rule 57 (term -> term / factor .)
    <               reduce using rule 57 (term -> term / factor .)
    ~               reduce using rule 57 (term -> term / factor .)
    AND             reduce using rule 57 (term -> term / factor .)
    OR              reduce using rule 57 (term -> term / factor .)
    :               reduce using rule 57 (term -> term / factor .)
    ]               reduce using rule 57 (term -> term / factor .)
    ,               reduce using rule 57 (term -> term / factor .)
    )               reduce using rule 57 (term -> term / factor .)
    NEWLINE         reduce using rule 57 (term -> term / factor .)


state 149

    (73) position -> ( expr , expr . )

    )               shift and go to state 164


state 150

    (40) or_test -> or_test OR and_test .
    (42) and_test -> and_test . AND not_test

    OR              reduce using rule 40 (or_test -> or_test OR and_test .)
    NEWLINE         reduce using rule 40 (or_test -> or_test OR and_test .)
    :               reduce using rule 40 (or_test -> or_test OR and_test .)
    ]               reduce using rule 40 (or_test -> or_test OR and_test .)
    ,               reduce using rule 40 (or_test -> or_test OR and_test .)
    )               reduce using rule 40 (or_test -> or_test OR and_test .)
    AND             shift and go to state 111


state 151

    (76) trailer -> [ expr ] .

    .               reduce using rule 76 (trailer -> [ expr ] .)
    [               reduce using rule 76 (trailer -> [ expr ] .)
    *               reduce using rule 76 (trailer -> [ expr ] .)
    /               reduce using rule 76 (trailer -> [ expr ] .)
    %               reduce using rule 76 (trailer -> [ expr ] .)
    +               reduce using rule 76 (trailer -> [ expr ] .)
    -               reduce using rule 76 (trailer -> [ expr ] .)
    =               reduce using rule 76 (trailer -> [ expr ] .)
    >               reduce using rule 76 (trailer -> [ expr ] .)
    <               reduce using rule 76 (trailer -> [ expr ] .)
    ~               reduce using rule 76 (trailer -> [ expr ] .)
    AND             reduce using rule 76 (trailer -> [ expr ] .)
    OR              reduce using rule 76 (trailer -> [ expr ] .)
    )               reduce using rule 76 (trailer -> [ expr ] .)
    ,               reduce using rule 76 (trailer -> [ expr ] .)
    ]               reduce using rule 76 (trailer -> [ expr ] .)
    NEWLINE         reduce using rule 76 (trailer -> [ expr ] .)
    :               reduce using rule 76 (trailer -> [ expr ] .)


state 152

    (22) assign_stmt -> power : = expr . NEWLINE

    NEWLINE         shift and go to state 165


state 153

    (80) parameter_list -> parameter_list , expr .

    ]               reduce using rule 80 (parameter_list -> parameter_list , expr .)
    ,               reduce using rule 80 (parameter_list -> parameter_list , expr .)
    )               reduce using rule 80 (parameter_list -> parameter_list , expr .)


state 154

    (78) func_expr -> ID ( parameter_list ) .

    .               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    [               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    *               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    /               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    %               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    +               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    -               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    =               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    >               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    <               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    ~               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    AND             reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    OR              reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    )               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    ,               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    ]               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    NEWLINE         reduce using rule 78 (func_expr -> ID ( parameter_list ) .)
    :               reduce using rule 78 (func_expr -> ID ( parameter_list ) .)


state 155

    (23) init_assign_stmt -> DEF INIT : NEWLINE INDENT . init_stmt DEDENT
    (24) init_stmt -> . STRING NUMBER position NEWLINE
    (25) init_stmt -> . init_stmt STRING NUMBER position NEWLINE

    STRING          shift and go to state 166

    init_stmt                      shift and go to state 167

state 156

    (35) parameters -> parameters , parameter .

    :               reduce using rule 35 (parameters -> parameters , parameter .)
    ,               reduce using rule 35 (parameters -> parameters , parameter .)


state 157

    (31) funcdef -> DEF ID parameters : suite .

    DEDENT          reduce using rule 31 (funcdef -> DEF ID parameters : suite .)
    DEF             reduce using rule 31 (funcdef -> DEF ID parameters : suite .)


state 158

    (91) suite -> NEWLINE INDENT . suite_stmt DEDENT
    (92) suite_stmt -> . stmt
    (93) suite_stmt -> . suite_stmt stmt
    (14) stmt -> . simple_stmt
    (15) stmt -> . compound_stmt
    (16) simple_stmt -> . assign_stmt
    (17) simple_stmt -> . flow_stmt
    (18) compound_stmt -> . func_expr NEWLINE
    (19) compound_stmt -> . for_stmt
    (20) compound_stmt -> . if_stmt
    (21) compound_stmt -> . while_stmt
    (22) assign_stmt -> . power : = expr NEWLINE
    (28) flow_stmt -> . break_stmt
    (29) flow_stmt -> . continue_stmt
    (30) flow_stmt -> . return_stmt
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )
    (81) for_stmt -> . FOR ID : = NUMBER TO NUMBER : suite
    (82) for_stmt -> . FOR ID IN expr : suite
    (83) if_stmt -> . IF expr : suite
    (84) if_stmt -> . IF expr : suite elseif_stmt
    (85) if_stmt -> . IF expr : suite ELSE : suite
    (86) if_stmt -> . IF expr : suite elseif_stmt ELSE : suite
    (89) while_stmt -> . WHILE expr : suite
    (62) power -> . atom
    (63) power -> . power trailer
    (96) break_stmt -> . BREAK NEWLINE
    (95) continue_stmt -> . CONTINUE NEWLINE
    (94) return_stmt -> . RETURN expr NEWLINE
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )

    ID              shift and go to state 180
    FOR             shift and go to state 173
    IF              shift and go to state 181
    WHILE           shift and go to state 169
    BREAK           shift and go to state 183
    CONTINUE        shift and go to state 185
    RETURN          shift and go to state 168
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    return_stmt                    shift and go to state 170
    array                          shift and go to state 60
    func_expr                      shift and go to state 187
    flow_stmt                      shift and go to state 172
    continue_stmt                  shift and go to state 186
    assign_stmt                    shift and go to state 174
    suite_stmt                     shift and go to state 171
    compound_stmt                  shift and go to state 175
    break_stmt                     shift and go to state 176
    power                          shift and go to state 65
    simple_stmt                    shift and go to state 177
    stmt                           shift and go to state 178
    for_stmt                       shift and go to state 179
    atom                           shift and go to state 66
    if_stmt                        shift and go to state 182
    while_stmt                     shift and go to state 184
    position                       shift and go to state 71

state 159

    (33) funcdef -> funcdef DEF ID parameters : . suite
    (90) suite -> . NEWLINE
    (91) suite -> . NEWLINE INDENT suite_stmt DEDENT

    NEWLINE         shift and go to state 133

    suite                          shift and go to state 188

state 160

    (34) funcdef -> funcdef DEF ID : suite .

    DEDENT          reduce using rule 34 (funcdef -> funcdef DEF ID : suite .)
    DEF             reduce using rule 34 (funcdef -> funcdef DEF ID : suite .)


state 161

    (49) comparison -> comparison > = operand .
    (53) operand -> operand . + term
    (54) operand -> operand . - term

    =               reduce using rule 49 (comparison -> comparison > = operand .)
    >               reduce using rule 49 (comparison -> comparison > = operand .)
    <               reduce using rule 49 (comparison -> comparison > = operand .)
    ~               reduce using rule 49 (comparison -> comparison > = operand .)
    AND             reduce using rule 49 (comparison -> comparison > = operand .)
    OR              reduce using rule 49 (comparison -> comparison > = operand .)
    )               reduce using rule 49 (comparison -> comparison > = operand .)
    ,               reduce using rule 49 (comparison -> comparison > = operand .)
    ]               reduce using rule 49 (comparison -> comparison > = operand .)
    NEWLINE         reduce using rule 49 (comparison -> comparison > = operand .)
    :               reduce using rule 49 (comparison -> comparison > = operand .)
    +               shift and go to state 107
    -               shift and go to state 108


state 162

    (50) comparison -> comparison < = operand .
    (53) operand -> operand . + term
    (54) operand -> operand . - term

    =               reduce using rule 50 (comparison -> comparison < = operand .)
    >               reduce using rule 50 (comparison -> comparison < = operand .)
    <               reduce using rule 50 (comparison -> comparison < = operand .)
    ~               reduce using rule 50 (comparison -> comparison < = operand .)
    AND             reduce using rule 50 (comparison -> comparison < = operand .)
    OR              reduce using rule 50 (comparison -> comparison < = operand .)
    )               reduce using rule 50 (comparison -> comparison < = operand .)
    ,               reduce using rule 50 (comparison -> comparison < = operand .)
    ]               reduce using rule 50 (comparison -> comparison < = operand .)
    NEWLINE         reduce using rule 50 (comparison -> comparison < = operand .)
    :               reduce using rule 50 (comparison -> comparison < = operand .)
    +               shift and go to state 107
    -               shift and go to state 108


state 163

    (51) comparison -> comparison ~ = operand .
    (53) operand -> operand . + term
    (54) operand -> operand . - term

    =               reduce using rule 51 (comparison -> comparison ~ = operand .)
    >               reduce using rule 51 (comparison -> comparison ~ = operand .)
    <               reduce using rule 51 (comparison -> comparison ~ = operand .)
    ~               reduce using rule 51 (comparison -> comparison ~ = operand .)
    AND             reduce using rule 51 (comparison -> comparison ~ = operand .)
    OR              reduce using rule 51 (comparison -> comparison ~ = operand .)
    )               reduce using rule 51 (comparison -> comparison ~ = operand .)
    ,               reduce using rule 51 (comparison -> comparison ~ = operand .)
    ]               reduce using rule 51 (comparison -> comparison ~ = operand .)
    NEWLINE         reduce using rule 51 (comparison -> comparison ~ = operand .)
    :               reduce using rule 51 (comparison -> comparison ~ = operand .)
    +               shift and go to state 107
    -               shift and go to state 108


state 164

    (73) position -> ( expr , expr ) .

    .               reduce using rule 73 (position -> ( expr , expr ) .)
    [               reduce using rule 73 (position -> ( expr , expr ) .)
    *               reduce using rule 73 (position -> ( expr , expr ) .)
    /               reduce using rule 73 (position -> ( expr , expr ) .)
    %               reduce using rule 73 (position -> ( expr , expr ) .)
    +               reduce using rule 73 (position -> ( expr , expr ) .)
    -               reduce using rule 73 (position -> ( expr , expr ) .)
    =               reduce using rule 73 (position -> ( expr , expr ) .)
    >               reduce using rule 73 (position -> ( expr , expr ) .)
    <               reduce using rule 73 (position -> ( expr , expr ) .)
    ~               reduce using rule 73 (position -> ( expr , expr ) .)
    AND             reduce using rule 73 (position -> ( expr , expr ) .)
    OR              reduce using rule 73 (position -> ( expr , expr ) .)
    ,               reduce using rule 73 (position -> ( expr , expr ) .)
    :               reduce using rule 73 (position -> ( expr , expr ) .)
    )               reduce using rule 73 (position -> ( expr , expr ) .)
    ]               reduce using rule 73 (position -> ( expr , expr ) .)
    NEWLINE         reduce using rule 73 (position -> ( expr , expr ) .)


state 165

    (22) assign_stmt -> power : = expr NEWLINE .

    DEDENT          reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    ID              reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    FOR             reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    IF              reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    WHILE           reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    BREAK           reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    CONTINUE        reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    RETURN          reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    STRING          reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    NUMBER          reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    BOOLEAN         reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    NIL             reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    (               reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    [               reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    GLOBAL          reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)
    DEF             reduce using rule 22 (assign_stmt -> power : = expr NEWLINE .)


state 166

    (24) init_stmt -> STRING . NUMBER position NEWLINE

    NUMBER          shift and go to state 189


state 167

    (23) init_assign_stmt -> DEF INIT : NEWLINE INDENT init_stmt . DEDENT
    (25) init_stmt -> init_stmt . STRING NUMBER position NEWLINE

    DEDENT          shift and go to state 190
    STRING          shift and go to state 191


state 168

    (94) return_stmt -> RETURN . expr NEWLINE
    (38) expr -> . or_test
    (39) or_test -> . and_test
    (40) or_test -> . or_test OR and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    power                          shift and go to state 85
    expr                           shift and go to state 192
    atom                           shift and go to state 66
    or_test                        shift and go to state 90
    and_test                       shift and go to state 86
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 169

    (89) while_stmt -> WHILE . expr : suite
    (38) expr -> . or_test
    (39) or_test -> . and_test
    (40) or_test -> . or_test OR and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    position                       shift and go to state 71
    power                          shift and go to state 85
    expr                           shift and go to state 193
    atom                           shift and go to state 66
    or_test                        shift and go to state 90
    and_test                       shift and go to state 86
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 170

    (30) flow_stmt -> return_stmt .

    DEDENT          reduce using rule 30 (flow_stmt -> return_stmt .)
    ID              reduce using rule 30 (flow_stmt -> return_stmt .)
    FOR             reduce using rule 30 (flow_stmt -> return_stmt .)
    IF              reduce using rule 30 (flow_stmt -> return_stmt .)
    WHILE           reduce using rule 30 (flow_stmt -> return_stmt .)
    BREAK           reduce using rule 30 (flow_stmt -> return_stmt .)
    CONTINUE        reduce using rule 30 (flow_stmt -> return_stmt .)
    RETURN          reduce using rule 30 (flow_stmt -> return_stmt .)
    STRING          reduce using rule 30 (flow_stmt -> return_stmt .)
    NUMBER          reduce using rule 30 (flow_stmt -> return_stmt .)
    BOOLEAN         reduce using rule 30 (flow_stmt -> return_stmt .)
    NIL             reduce using rule 30 (flow_stmt -> return_stmt .)
    (               reduce using rule 30 (flow_stmt -> return_stmt .)
    [               reduce using rule 30 (flow_stmt -> return_stmt .)


state 171

    (91) suite -> NEWLINE INDENT suite_stmt . DEDENT
    (93) suite_stmt -> suite_stmt . stmt
    (14) stmt -> . simple_stmt
    (15) stmt -> . compound_stmt
    (16) simple_stmt -> . assign_stmt
    (17) simple_stmt -> . flow_stmt
    (18) compound_stmt -> . func_expr NEWLINE
    (19) compound_stmt -> . for_stmt
    (20) compound_stmt -> . if_stmt
    (21) compound_stmt -> . while_stmt
    (22) assign_stmt -> . power : = expr NEWLINE
    (28) flow_stmt -> . break_stmt
    (29) flow_stmt -> . continue_stmt
    (30) flow_stmt -> . return_stmt
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )
    (81) for_stmt -> . FOR ID : = NUMBER TO NUMBER : suite
    (82) for_stmt -> . FOR ID IN expr : suite
    (83) if_stmt -> . IF expr : suite
    (84) if_stmt -> . IF expr : suite elseif_stmt
    (85) if_stmt -> . IF expr : suite ELSE : suite
    (86) if_stmt -> . IF expr : suite elseif_stmt ELSE : suite
    (89) while_stmt -> . WHILE expr : suite
    (62) power -> . atom
    (63) power -> . power trailer
    (96) break_stmt -> . BREAK NEWLINE
    (95) continue_stmt -> . CONTINUE NEWLINE
    (94) return_stmt -> . RETURN expr NEWLINE
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )

    DEDENT          shift and go to state 194
    ID              shift and go to state 180
    FOR             shift and go to state 173
    IF              shift and go to state 181
    WHILE           shift and go to state 169
    BREAK           shift and go to state 183
    CONTINUE        shift and go to state 185
    RETURN          shift and go to state 168
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    return_stmt                    shift and go to state 170
    array                          shift and go to state 60
    func_expr                      shift and go to state 187
    flow_stmt                      shift and go to state 172
    continue_stmt                  shift and go to state 186
    assign_stmt                    shift and go to state 174
    compound_stmt                  shift and go to state 175
    break_stmt                     shift and go to state 176
    power                          shift and go to state 65
    simple_stmt                    shift and go to state 177
    stmt                           shift and go to state 195
    for_stmt                       shift and go to state 179
    atom                           shift and go to state 66
    if_stmt                        shift and go to state 182
    while_stmt                     shift and go to state 184
    position                       shift and go to state 71

state 172

    (17) simple_stmt -> flow_stmt .

    DEDENT          reduce using rule 17 (simple_stmt -> flow_stmt .)
    ID              reduce using rule 17 (simple_stmt -> flow_stmt .)
    FOR             reduce using rule 17 (simple_stmt -> flow_stmt .)
    IF              reduce using rule 17 (simple_stmt -> flow_stmt .)
    WHILE           reduce using rule 17 (simple_stmt -> flow_stmt .)
    BREAK           reduce using rule 17 (simple_stmt -> flow_stmt .)
    CONTINUE        reduce using rule 17 (simple_stmt -> flow_stmt .)
    RETURN          reduce using rule 17 (simple_stmt -> flow_stmt .)
    STRING          reduce using rule 17 (simple_stmt -> flow_stmt .)
    NUMBER          reduce using rule 17 (simple_stmt -> flow_stmt .)
    BOOLEAN         reduce using rule 17 (simple_stmt -> flow_stmt .)
    NIL             reduce using rule 17 (simple_stmt -> flow_stmt .)
    (               reduce using rule 17 (simple_stmt -> flow_stmt .)
    [               reduce using rule 17 (simple_stmt -> flow_stmt .)


state 173

    (81) for_stmt -> FOR . ID : = NUMBER TO NUMBER : suite
    (82) for_stmt -> FOR . ID IN expr : suite

    ID              shift and go to state 196


state 174

    (16) simple_stmt -> assign_stmt .

    DEDENT          reduce using rule 16 (simple_stmt -> assign_stmt .)
    ID              reduce using rule 16 (simple_stmt -> assign_stmt .)
    FOR             reduce using rule 16 (simple_stmt -> assign_stmt .)
    IF              reduce using rule 16 (simple_stmt -> assign_stmt .)
    WHILE           reduce using rule 16 (simple_stmt -> assign_stmt .)
    BREAK           reduce using rule 16 (simple_stmt -> assign_stmt .)
    CONTINUE        reduce using rule 16 (simple_stmt -> assign_stmt .)
    RETURN          reduce using rule 16 (simple_stmt -> assign_stmt .)
    STRING          reduce using rule 16 (simple_stmt -> assign_stmt .)
    NUMBER          reduce using rule 16 (simple_stmt -> assign_stmt .)
    BOOLEAN         reduce using rule 16 (simple_stmt -> assign_stmt .)
    NIL             reduce using rule 16 (simple_stmt -> assign_stmt .)
    (               reduce using rule 16 (simple_stmt -> assign_stmt .)
    [               reduce using rule 16 (simple_stmt -> assign_stmt .)


state 175

    (15) stmt -> compound_stmt .

    DEDENT          reduce using rule 15 (stmt -> compound_stmt .)
    ID              reduce using rule 15 (stmt -> compound_stmt .)
    FOR             reduce using rule 15 (stmt -> compound_stmt .)
    IF              reduce using rule 15 (stmt -> compound_stmt .)
    WHILE           reduce using rule 15 (stmt -> compound_stmt .)
    BREAK           reduce using rule 15 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 15 (stmt -> compound_stmt .)
    RETURN          reduce using rule 15 (stmt -> compound_stmt .)
    STRING          reduce using rule 15 (stmt -> compound_stmt .)
    NUMBER          reduce using rule 15 (stmt -> compound_stmt .)
    BOOLEAN         reduce using rule 15 (stmt -> compound_stmt .)
    NIL             reduce using rule 15 (stmt -> compound_stmt .)
    (               reduce using rule 15 (stmt -> compound_stmt .)
    [               reduce using rule 15 (stmt -> compound_stmt .)


state 176

    (28) flow_stmt -> break_stmt .

    DEDENT          reduce using rule 28 (flow_stmt -> break_stmt .)
    ID              reduce using rule 28 (flow_stmt -> break_stmt .)
    FOR             reduce using rule 28 (flow_stmt -> break_stmt .)
    IF              reduce using rule 28 (flow_stmt -> break_stmt .)
    WHILE           reduce using rule 28 (flow_stmt -> break_stmt .)
    BREAK           reduce using rule 28 (flow_stmt -> break_stmt .)
    CONTINUE        reduce using rule 28 (flow_stmt -> break_stmt .)
    RETURN          reduce using rule 28 (flow_stmt -> break_stmt .)
    STRING          reduce using rule 28 (flow_stmt -> break_stmt .)
    NUMBER          reduce using rule 28 (flow_stmt -> break_stmt .)
    BOOLEAN         reduce using rule 28 (flow_stmt -> break_stmt .)
    NIL             reduce using rule 28 (flow_stmt -> break_stmt .)
    (               reduce using rule 28 (flow_stmt -> break_stmt .)
    [               reduce using rule 28 (flow_stmt -> break_stmt .)


state 177

    (14) stmt -> simple_stmt .

    DEDENT          reduce using rule 14 (stmt -> simple_stmt .)
    ID              reduce using rule 14 (stmt -> simple_stmt .)
    FOR             reduce using rule 14 (stmt -> simple_stmt .)
    IF              reduce using rule 14 (stmt -> simple_stmt .)
    WHILE           reduce using rule 14 (stmt -> simple_stmt .)
    BREAK           reduce using rule 14 (stmt -> simple_stmt .)
    CONTINUE        reduce using rule 14 (stmt -> simple_stmt .)
    RETURN          reduce using rule 14 (stmt -> simple_stmt .)
    STRING          reduce using rule 14 (stmt -> simple_stmt .)
    NUMBER          reduce using rule 14 (stmt -> simple_stmt .)
    BOOLEAN         reduce using rule 14 (stmt -> simple_stmt .)
    NIL             reduce using rule 14 (stmt -> simple_stmt .)
    (               reduce using rule 14 (stmt -> simple_stmt .)
    [               reduce using rule 14 (stmt -> simple_stmt .)


state 178

    (92) suite_stmt -> stmt .

    DEDENT          reduce using rule 92 (suite_stmt -> stmt .)
    ID              reduce using rule 92 (suite_stmt -> stmt .)
    FOR             reduce using rule 92 (suite_stmt -> stmt .)
    IF              reduce using rule 92 (suite_stmt -> stmt .)
    WHILE           reduce using rule 92 (suite_stmt -> stmt .)
    BREAK           reduce using rule 92 (suite_stmt -> stmt .)
    CONTINUE        reduce using rule 92 (suite_stmt -> stmt .)
    RETURN          reduce using rule 92 (suite_stmt -> stmt .)
    STRING          reduce using rule 92 (suite_stmt -> stmt .)
    NUMBER          reduce using rule 92 (suite_stmt -> stmt .)
    BOOLEAN         reduce using rule 92 (suite_stmt -> stmt .)
    NIL             reduce using rule 92 (suite_stmt -> stmt .)
    (               reduce using rule 92 (suite_stmt -> stmt .)
    [               reduce using rule 92 (suite_stmt -> stmt .)


state 179

    (19) compound_stmt -> for_stmt .

    DEDENT          reduce using rule 19 (compound_stmt -> for_stmt .)
    ID              reduce using rule 19 (compound_stmt -> for_stmt .)
    FOR             reduce using rule 19 (compound_stmt -> for_stmt .)
    IF              reduce using rule 19 (compound_stmt -> for_stmt .)
    WHILE           reduce using rule 19 (compound_stmt -> for_stmt .)
    BREAK           reduce using rule 19 (compound_stmt -> for_stmt .)
    CONTINUE        reduce using rule 19 (compound_stmt -> for_stmt .)
    RETURN          reduce using rule 19 (compound_stmt -> for_stmt .)
    STRING          reduce using rule 19 (compound_stmt -> for_stmt .)
    NUMBER          reduce using rule 19 (compound_stmt -> for_stmt .)
    BOOLEAN         reduce using rule 19 (compound_stmt -> for_stmt .)
    NIL             reduce using rule 19 (compound_stmt -> for_stmt .)
    (               reduce using rule 19 (compound_stmt -> for_stmt .)
    [               reduce using rule 19 (compound_stmt -> for_stmt .)


state 180

    (77) func_expr -> ID . ( )
    (78) func_expr -> ID . ( parameter_list )
    (66) atom -> ID .

    (               shift and go to state 98
    :               reduce using rule 66 (atom -> ID .)
    .               reduce using rule 66 (atom -> ID .)
    [               reduce using rule 66 (atom -> ID .)


state 181

    (83) if_stmt -> IF . expr : suite
    (84) if_stmt -> IF . expr : suite elseif_stmt
    (85) if_stmt -> IF . expr : suite ELSE : suite
    (86) if_stmt -> IF . expr : suite elseif_stmt ELSE : suite
    (38) expr -> . or_test
    (39) or_test -> . and_test
    (40) or_test -> . or_test OR and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    position                       shift and go to state 71
    power                          shift and go to state 85
    expr                           shift and go to state 197
    atom                           shift and go to state 66
    or_test                        shift and go to state 90
    and_test                       shift and go to state 86
    operand                        shift and go to state 81
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 182

    (20) compound_stmt -> if_stmt .

    DEDENT          reduce using rule 20 (compound_stmt -> if_stmt .)
    ID              reduce using rule 20 (compound_stmt -> if_stmt .)
    FOR             reduce using rule 20 (compound_stmt -> if_stmt .)
    IF              reduce using rule 20 (compound_stmt -> if_stmt .)
    WHILE           reduce using rule 20 (compound_stmt -> if_stmt .)
    BREAK           reduce using rule 20 (compound_stmt -> if_stmt .)
    CONTINUE        reduce using rule 20 (compound_stmt -> if_stmt .)
    RETURN          reduce using rule 20 (compound_stmt -> if_stmt .)
    STRING          reduce using rule 20 (compound_stmt -> if_stmt .)
    NUMBER          reduce using rule 20 (compound_stmt -> if_stmt .)
    BOOLEAN         reduce using rule 20 (compound_stmt -> if_stmt .)
    NIL             reduce using rule 20 (compound_stmt -> if_stmt .)
    (               reduce using rule 20 (compound_stmt -> if_stmt .)
    [               reduce using rule 20 (compound_stmt -> if_stmt .)


state 183

    (96) break_stmt -> BREAK . NEWLINE

    NEWLINE         shift and go to state 198


state 184

    (21) compound_stmt -> while_stmt .

    DEDENT          reduce using rule 21 (compound_stmt -> while_stmt .)
    ID              reduce using rule 21 (compound_stmt -> while_stmt .)
    FOR             reduce using rule 21 (compound_stmt -> while_stmt .)
    IF              reduce using rule 21 (compound_stmt -> while_stmt .)
    WHILE           reduce using rule 21 (compound_stmt -> while_stmt .)
    BREAK           reduce using rule 21 (compound_stmt -> while_stmt .)
    CONTINUE        reduce using rule 21 (compound_stmt -> while_stmt .)
    RETURN          reduce using rule 21 (compound_stmt -> while_stmt .)
    STRING          reduce using rule 21 (compound_stmt -> while_stmt .)
    NUMBER          reduce using rule 21 (compound_stmt -> while_stmt .)
    BOOLEAN         reduce using rule 21 (compound_stmt -> while_stmt .)
    NIL             reduce using rule 21 (compound_stmt -> while_stmt .)
    (               reduce using rule 21 (compound_stmt -> while_stmt .)
    [               reduce using rule 21 (compound_stmt -> while_stmt .)


state 185

    (95) continue_stmt -> CONTINUE . NEWLINE

    NEWLINE         shift and go to state 199


state 186

    (29) flow_stmt -> continue_stmt .

    DEDENT          reduce using rule 29 (flow_stmt -> continue_stmt .)
    ID              reduce using rule 29 (flow_stmt -> continue_stmt .)
    FOR             reduce using rule 29 (flow_stmt -> continue_stmt .)
    IF              reduce using rule 29 (flow_stmt -> continue_stmt .)
    WHILE           reduce using rule 29 (flow_stmt -> continue_stmt .)
    BREAK           reduce using rule 29 (flow_stmt -> continue_stmt .)
    CONTINUE        reduce using rule 29 (flow_stmt -> continue_stmt .)
    RETURN          reduce using rule 29 (flow_stmt -> continue_stmt .)
    STRING          reduce using rule 29 (flow_stmt -> continue_stmt .)
    NUMBER          reduce using rule 29 (flow_stmt -> continue_stmt .)
    BOOLEAN         reduce using rule 29 (flow_stmt -> continue_stmt .)
    NIL             reduce using rule 29 (flow_stmt -> continue_stmt .)
    (               reduce using rule 29 (flow_stmt -> continue_stmt .)
    [               reduce using rule 29 (flow_stmt -> continue_stmt .)


state 187

    (18) compound_stmt -> func_expr . NEWLINE
    (71) atom -> func_expr .

    NEWLINE         shift and go to state 200
    :               reduce using rule 71 (atom -> func_expr .)
    .               reduce using rule 71 (atom -> func_expr .)
    [               reduce using rule 71 (atom -> func_expr .)


state 188

    (33) funcdef -> funcdef DEF ID parameters : suite .

    DEDENT          reduce using rule 33 (funcdef -> funcdef DEF ID parameters : suite .)
    DEF             reduce using rule 33 (funcdef -> funcdef DEF ID parameters : suite .)


state 189

    (24) init_stmt -> STRING NUMBER . position NEWLINE
    (73) position -> . ( expr , expr )

    (               shift and go to state 201

    position                       shift and go to state 202

state 190

    (23) init_assign_stmt -> DEF INIT : NEWLINE INDENT init_stmt DEDENT .

    DEF             reduce using rule 23 (init_assign_stmt -> DEF INIT : NEWLINE INDENT init_stmt DEDENT .)


state 191

    (25) init_stmt -> init_stmt STRING . NUMBER position NEWLINE

    NUMBER          shift and go to state 203


state 192

    (94) return_stmt -> RETURN expr . NEWLINE

    NEWLINE         shift and go to state 204


state 193

    (89) while_stmt -> WHILE expr . : suite

    :               shift and go to state 205


state 194

    (91) suite -> NEWLINE INDENT suite_stmt DEDENT .

    DEDENT          reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    DEF             reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    ELSE            reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    ELSEIF          reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    ID              reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    FOR             reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    IF              reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    WHILE           reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    BREAK           reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    CONTINUE        reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    RETURN          reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    STRING          reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    NUMBER          reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    BOOLEAN         reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    NIL             reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    (               reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)
    [               reduce using rule 91 (suite -> NEWLINE INDENT suite_stmt DEDENT .)


state 195

    (93) suite_stmt -> suite_stmt stmt .

    DEDENT          reduce using rule 93 (suite_stmt -> suite_stmt stmt .)
    ID              reduce using rule 93 (suite_stmt -> suite_stmt stmt .)
    FOR             reduce using rule 93 (suite_stmt -> suite_stmt stmt .)
    IF              reduce using rule 93 (suite_stmt -> suite_stmt stmt .)
    WHILE           reduce using rule 93 (suite_stmt -> suite_stmt stmt .)
    BREAK           reduce using rule 93 (suite_stmt -> suite_stmt stmt .)
    CONTINUE        reduce using rule 93 (suite_stmt -> suite_stmt stmt .)
    RETURN          reduce using rule 93 (suite_stmt -> suite_stmt stmt .)
    STRING          reduce using rule 93 (suite_stmt -> suite_stmt stmt .)
    NUMBER          reduce using rule 93 (suite_stmt -> suite_stmt stmt .)
    BOOLEAN         reduce using rule 93 (suite_stmt -> suite_stmt stmt .)
    NIL             reduce using rule 93 (suite_stmt -> suite_stmt stmt .)
    (               reduce using rule 93 (suite_stmt -> suite_stmt stmt .)
    [               reduce using rule 93 (suite_stmt -> suite_stmt stmt .)


state 196

    (81) for_stmt -> FOR ID . : = NUMBER TO NUMBER : suite
    (82) for_stmt -> FOR ID . IN expr : suite

    :               shift and go to state 207
    IN              shift and go to state 206


state 197

    (83) if_stmt -> IF expr . : suite
    (84) if_stmt -> IF expr . : suite elseif_stmt
    (85) if_stmt -> IF expr . : suite ELSE : suite
    (86) if_stmt -> IF expr . : suite elseif_stmt ELSE : suite

    :               shift and go to state 208


state 198

    (96) break_stmt -> BREAK NEWLINE .

    DEDENT          reduce using rule 96 (break_stmt -> BREAK NEWLINE .)
    ID              reduce using rule 96 (break_stmt -> BREAK NEWLINE .)
    FOR             reduce using rule 96 (break_stmt -> BREAK NEWLINE .)
    IF              reduce using rule 96 (break_stmt -> BREAK NEWLINE .)
    WHILE           reduce using rule 96 (break_stmt -> BREAK NEWLINE .)
    BREAK           reduce using rule 96 (break_stmt -> BREAK NEWLINE .)
    CONTINUE        reduce using rule 96 (break_stmt -> BREAK NEWLINE .)
    RETURN          reduce using rule 96 (break_stmt -> BREAK NEWLINE .)
    STRING          reduce using rule 96 (break_stmt -> BREAK NEWLINE .)
    NUMBER          reduce using rule 96 (break_stmt -> BREAK NEWLINE .)
    BOOLEAN         reduce using rule 96 (break_stmt -> BREAK NEWLINE .)
    NIL             reduce using rule 96 (break_stmt -> BREAK NEWLINE .)
    (               reduce using rule 96 (break_stmt -> BREAK NEWLINE .)
    [               reduce using rule 96 (break_stmt -> BREAK NEWLINE .)


state 199

    (95) continue_stmt -> CONTINUE NEWLINE .

    DEDENT          reduce using rule 95 (continue_stmt -> CONTINUE NEWLINE .)
    ID              reduce using rule 95 (continue_stmt -> CONTINUE NEWLINE .)
    FOR             reduce using rule 95 (continue_stmt -> CONTINUE NEWLINE .)
    IF              reduce using rule 95 (continue_stmt -> CONTINUE NEWLINE .)
    WHILE           reduce using rule 95 (continue_stmt -> CONTINUE NEWLINE .)
    BREAK           reduce using rule 95 (continue_stmt -> CONTINUE NEWLINE .)
    CONTINUE        reduce using rule 95 (continue_stmt -> CONTINUE NEWLINE .)
    RETURN          reduce using rule 95 (continue_stmt -> CONTINUE NEWLINE .)
    STRING          reduce using rule 95 (continue_stmt -> CONTINUE NEWLINE .)
    NUMBER          reduce using rule 95 (continue_stmt -> CONTINUE NEWLINE .)
    BOOLEAN         reduce using rule 95 (continue_stmt -> CONTINUE NEWLINE .)
    NIL             reduce using rule 95 (continue_stmt -> CONTINUE NEWLINE .)
    (               reduce using rule 95 (continue_stmt -> CONTINUE NEWLINE .)
    [               reduce using rule 95 (continue_stmt -> CONTINUE NEWLINE .)


state 200

    (18) compound_stmt -> func_expr NEWLINE .

    DEDENT          reduce using rule 18 (compound_stmt -> func_expr NEWLINE .)
    ID              reduce using rule 18 (compound_stmt -> func_expr NEWLINE .)
    FOR             reduce using rule 18 (compound_stmt -> func_expr NEWLINE .)
    IF              reduce using rule 18 (compound_stmt -> func_expr NEWLINE .)
    WHILE           reduce using rule 18 (compound_stmt -> func_expr NEWLINE .)
    BREAK           reduce using rule 18 (compound_stmt -> func_expr NEWLINE .)
    CONTINUE        reduce using rule 18 (compound_stmt -> func_expr NEWLINE .)
    RETURN          reduce using rule 18 (compound_stmt -> func_expr NEWLINE .)
    STRING          reduce using rule 18 (compound_stmt -> func_expr NEWLINE .)
    NUMBER          reduce using rule 18 (compound_stmt -> func_expr NEWLINE .)
    BOOLEAN         reduce using rule 18 (compound_stmt -> func_expr NEWLINE .)
    NIL             reduce using rule 18 (compound_stmt -> func_expr NEWLINE .)
    (               reduce using rule 18 (compound_stmt -> func_expr NEWLINE .)
    [               reduce using rule 18 (compound_stmt -> func_expr NEWLINE .)


state 201

    (73) position -> ( . expr , expr )
    (38) expr -> . or_test
    (39) or_test -> . and_test
    (40) or_test -> . or_test OR and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    power                          shift and go to state 85
    expr                           shift and go to state 209
    atom                           shift and go to state 66
    or_test                        shift and go to state 90
    and_test                       shift and go to state 86
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    position                       shift and go to state 71
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 202

    (24) init_stmt -> STRING NUMBER position . NEWLINE

    NEWLINE         shift and go to state 210


state 203

    (25) init_stmt -> init_stmt STRING NUMBER . position NEWLINE
    (73) position -> . ( expr , expr )

    (               shift and go to state 201

    position                       shift and go to state 211

state 204

    (94) return_stmt -> RETURN expr NEWLINE .

    DEDENT          reduce using rule 94 (return_stmt -> RETURN expr NEWLINE .)
    ID              reduce using rule 94 (return_stmt -> RETURN expr NEWLINE .)
    FOR             reduce using rule 94 (return_stmt -> RETURN expr NEWLINE .)
    IF              reduce using rule 94 (return_stmt -> RETURN expr NEWLINE .)
    WHILE           reduce using rule 94 (return_stmt -> RETURN expr NEWLINE .)
    BREAK           reduce using rule 94 (return_stmt -> RETURN expr NEWLINE .)
    CONTINUE        reduce using rule 94 (return_stmt -> RETURN expr NEWLINE .)
    RETURN          reduce using rule 94 (return_stmt -> RETURN expr NEWLINE .)
    STRING          reduce using rule 94 (return_stmt -> RETURN expr NEWLINE .)
    NUMBER          reduce using rule 94 (return_stmt -> RETURN expr NEWLINE .)
    BOOLEAN         reduce using rule 94 (return_stmt -> RETURN expr NEWLINE .)
    NIL             reduce using rule 94 (return_stmt -> RETURN expr NEWLINE .)
    (               reduce using rule 94 (return_stmt -> RETURN expr NEWLINE .)
    [               reduce using rule 94 (return_stmt -> RETURN expr NEWLINE .)


state 205

    (89) while_stmt -> WHILE expr : . suite
    (90) suite -> . NEWLINE
    (91) suite -> . NEWLINE INDENT suite_stmt DEDENT

    NEWLINE         shift and go to state 133

    suite                          shift and go to state 212

state 206

    (82) for_stmt -> FOR ID IN . expr : suite
    (38) expr -> . or_test
    (39) or_test -> . and_test
    (40) or_test -> . or_test OR and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    position                       shift and go to state 71
    power                          shift and go to state 85
    expr                           shift and go to state 213
    atom                           shift and go to state 66
    or_test                        shift and go to state 90
    and_test                       shift and go to state 86
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 207

    (81) for_stmt -> FOR ID : . = NUMBER TO NUMBER : suite

    =               shift and go to state 214


state 208

    (83) if_stmt -> IF expr : . suite
    (84) if_stmt -> IF expr : . suite elseif_stmt
    (85) if_stmt -> IF expr : . suite ELSE : suite
    (86) if_stmt -> IF expr : . suite elseif_stmt ELSE : suite
    (90) suite -> . NEWLINE
    (91) suite -> . NEWLINE INDENT suite_stmt DEDENT

    NEWLINE         shift and go to state 133

    suite                          shift and go to state 215

state 209

    (73) position -> ( expr . , expr )

    ,               shift and go to state 120


state 210

    (24) init_stmt -> STRING NUMBER position NEWLINE .

    DEDENT          reduce using rule 24 (init_stmt -> STRING NUMBER position NEWLINE .)
    STRING          reduce using rule 24 (init_stmt -> STRING NUMBER position NEWLINE .)


state 211

    (25) init_stmt -> init_stmt STRING NUMBER position . NEWLINE

    NEWLINE         shift and go to state 216


state 212

    (89) while_stmt -> WHILE expr : suite .

    DEDENT          reduce using rule 89 (while_stmt -> WHILE expr : suite .)
    ID              reduce using rule 89 (while_stmt -> WHILE expr : suite .)
    FOR             reduce using rule 89 (while_stmt -> WHILE expr : suite .)
    IF              reduce using rule 89 (while_stmt -> WHILE expr : suite .)
    WHILE           reduce using rule 89 (while_stmt -> WHILE expr : suite .)
    BREAK           reduce using rule 89 (while_stmt -> WHILE expr : suite .)
    CONTINUE        reduce using rule 89 (while_stmt -> WHILE expr : suite .)
    RETURN          reduce using rule 89 (while_stmt -> WHILE expr : suite .)
    STRING          reduce using rule 89 (while_stmt -> WHILE expr : suite .)
    NUMBER          reduce using rule 89 (while_stmt -> WHILE expr : suite .)
    BOOLEAN         reduce using rule 89 (while_stmt -> WHILE expr : suite .)
    NIL             reduce using rule 89 (while_stmt -> WHILE expr : suite .)
    (               reduce using rule 89 (while_stmt -> WHILE expr : suite .)
    [               reduce using rule 89 (while_stmt -> WHILE expr : suite .)


state 213

    (82) for_stmt -> FOR ID IN expr . : suite

    :               shift and go to state 217


state 214

    (81) for_stmt -> FOR ID : = . NUMBER TO NUMBER : suite

    NUMBER          shift and go to state 218


state 215

    (83) if_stmt -> IF expr : suite .
    (84) if_stmt -> IF expr : suite . elseif_stmt
    (85) if_stmt -> IF expr : suite . ELSE : suite
    (86) if_stmt -> IF expr : suite . elseif_stmt ELSE : suite
    (87) elseif_stmt -> . ELSEIF expr : suite
    (88) elseif_stmt -> . elseif_stmt ELSEIF expr : suite

    DEDENT          reduce using rule 83 (if_stmt -> IF expr : suite .)
    ID              reduce using rule 83 (if_stmt -> IF expr : suite .)
    FOR             reduce using rule 83 (if_stmt -> IF expr : suite .)
    IF              reduce using rule 83 (if_stmt -> IF expr : suite .)
    WHILE           reduce using rule 83 (if_stmt -> IF expr : suite .)
    BREAK           reduce using rule 83 (if_stmt -> IF expr : suite .)
    CONTINUE        reduce using rule 83 (if_stmt -> IF expr : suite .)
    RETURN          reduce using rule 83 (if_stmt -> IF expr : suite .)
    STRING          reduce using rule 83 (if_stmt -> IF expr : suite .)
    NUMBER          reduce using rule 83 (if_stmt -> IF expr : suite .)
    BOOLEAN         reduce using rule 83 (if_stmt -> IF expr : suite .)
    NIL             reduce using rule 83 (if_stmt -> IF expr : suite .)
    (               reduce using rule 83 (if_stmt -> IF expr : suite .)
    [               reduce using rule 83 (if_stmt -> IF expr : suite .)
    ELSE            shift and go to state 219
    ELSEIF          shift and go to state 220

    elseif_stmt                    shift and go to state 221

state 216

    (25) init_stmt -> init_stmt STRING NUMBER position NEWLINE .

    DEDENT          reduce using rule 25 (init_stmt -> init_stmt STRING NUMBER position NEWLINE .)
    STRING          reduce using rule 25 (init_stmt -> init_stmt STRING NUMBER position NEWLINE .)


state 217

    (82) for_stmt -> FOR ID IN expr : . suite
    (90) suite -> . NEWLINE
    (91) suite -> . NEWLINE INDENT suite_stmt DEDENT

    NEWLINE         shift and go to state 133

    suite                          shift and go to state 222

state 218

    (81) for_stmt -> FOR ID : = NUMBER . TO NUMBER : suite

    TO              shift and go to state 223


state 219

    (85) if_stmt -> IF expr : suite ELSE . : suite

    :               shift and go to state 224


state 220

    (87) elseif_stmt -> ELSEIF . expr : suite
    (38) expr -> . or_test
    (39) or_test -> . and_test
    (40) or_test -> . or_test OR and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    position                       shift and go to state 71
    power                          shift and go to state 85
    expr                           shift and go to state 225
    atom                           shift and go to state 66
    or_test                        shift and go to state 90
    and_test                       shift and go to state 86
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    operand                        shift and go to state 81
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 221

    (84) if_stmt -> IF expr : suite elseif_stmt .
    (86) if_stmt -> IF expr : suite elseif_stmt . ELSE : suite
    (88) elseif_stmt -> elseif_stmt . ELSEIF expr : suite

    DEDENT          reduce using rule 84 (if_stmt -> IF expr : suite elseif_stmt .)
    ID              reduce using rule 84 (if_stmt -> IF expr : suite elseif_stmt .)
    FOR             reduce using rule 84 (if_stmt -> IF expr : suite elseif_stmt .)
    IF              reduce using rule 84 (if_stmt -> IF expr : suite elseif_stmt .)
    WHILE           reduce using rule 84 (if_stmt -> IF expr : suite elseif_stmt .)
    BREAK           reduce using rule 84 (if_stmt -> IF expr : suite elseif_stmt .)
    CONTINUE        reduce using rule 84 (if_stmt -> IF expr : suite elseif_stmt .)
    RETURN          reduce using rule 84 (if_stmt -> IF expr : suite elseif_stmt .)
    STRING          reduce using rule 84 (if_stmt -> IF expr : suite elseif_stmt .)
    NUMBER          reduce using rule 84 (if_stmt -> IF expr : suite elseif_stmt .)
    BOOLEAN         reduce using rule 84 (if_stmt -> IF expr : suite elseif_stmt .)
    NIL             reduce using rule 84 (if_stmt -> IF expr : suite elseif_stmt .)
    (               reduce using rule 84 (if_stmt -> IF expr : suite elseif_stmt .)
    [               reduce using rule 84 (if_stmt -> IF expr : suite elseif_stmt .)
    ELSE            shift and go to state 226
    ELSEIF          shift and go to state 227


state 222

    (82) for_stmt -> FOR ID IN expr : suite .

    DEDENT          reduce using rule 82 (for_stmt -> FOR ID IN expr : suite .)
    ID              reduce using rule 82 (for_stmt -> FOR ID IN expr : suite .)
    FOR             reduce using rule 82 (for_stmt -> FOR ID IN expr : suite .)
    IF              reduce using rule 82 (for_stmt -> FOR ID IN expr : suite .)
    WHILE           reduce using rule 82 (for_stmt -> FOR ID IN expr : suite .)
    BREAK           reduce using rule 82 (for_stmt -> FOR ID IN expr : suite .)
    CONTINUE        reduce using rule 82 (for_stmt -> FOR ID IN expr : suite .)
    RETURN          reduce using rule 82 (for_stmt -> FOR ID IN expr : suite .)
    STRING          reduce using rule 82 (for_stmt -> FOR ID IN expr : suite .)
    NUMBER          reduce using rule 82 (for_stmt -> FOR ID IN expr : suite .)
    BOOLEAN         reduce using rule 82 (for_stmt -> FOR ID IN expr : suite .)
    NIL             reduce using rule 82 (for_stmt -> FOR ID IN expr : suite .)
    (               reduce using rule 82 (for_stmt -> FOR ID IN expr : suite .)
    [               reduce using rule 82 (for_stmt -> FOR ID IN expr : suite .)


state 223

    (81) for_stmt -> FOR ID : = NUMBER TO . NUMBER : suite

    NUMBER          shift and go to state 228


state 224

    (85) if_stmt -> IF expr : suite ELSE : . suite
    (90) suite -> . NEWLINE
    (91) suite -> . NEWLINE INDENT suite_stmt DEDENT

    NEWLINE         shift and go to state 133

    suite                          shift and go to state 229

state 225

    (87) elseif_stmt -> ELSEIF expr . : suite

    :               shift and go to state 230


state 226

    (86) if_stmt -> IF expr : suite elseif_stmt ELSE . : suite

    :               shift and go to state 231


state 227

    (88) elseif_stmt -> elseif_stmt ELSEIF . expr : suite
    (38) expr -> . or_test
    (39) or_test -> . and_test
    (40) or_test -> . or_test OR and_test
    (41) and_test -> . not_test
    (42) and_test -> . and_test AND not_test
    (43) not_test -> . NOT not_test
    (44) not_test -> . comparison
    (45) comparison -> . operand
    (46) comparison -> . comparison = operand
    (47) comparison -> . comparison > operand
    (48) comparison -> . comparison < operand
    (49) comparison -> . comparison > = operand
    (50) comparison -> . comparison < = operand
    (51) comparison -> . comparison ~ = operand
    (52) operand -> . term
    (53) operand -> . operand + term
    (54) operand -> . operand - term
    (55) term -> . factor
    (56) term -> . term * factor
    (57) term -> . term / factor
    (58) term -> . term % factor
    (59) factor -> . power
    (60) factor -> . + factor
    (61) factor -> . - factor
    (62) power -> . atom
    (63) power -> . power trailer
    (64) atom -> . array
    (65) atom -> . position
    (66) atom -> . ID
    (67) atom -> . STRING
    (68) atom -> . NUMBER
    (69) atom -> . BOOLEAN
    (70) atom -> . NIL
    (71) atom -> . func_expr
    (72) atom -> . ( expr )
    (74) array -> . [ parameter_list ]
    (73) position -> . ( expr , expr )
    (77) func_expr -> . ID ( )
    (78) func_expr -> . ID ( parameter_list )

    NOT             shift and go to state 91
    +               shift and go to state 82
    -               shift and go to state 83
    ID              shift and go to state 68
    STRING          shift and go to state 64
    NUMBER          shift and go to state 59
    BOOLEAN         shift and go to state 70
    NIL             shift and go to state 69
    (               shift and go to state 62
    [               shift and go to state 67

    comparison                     shift and go to state 87
    term                           shift and go to state 88
    position                       shift and go to state 71
    power                          shift and go to state 85
    expr                           shift and go to state 232
    atom                           shift and go to state 66
    or_test                        shift and go to state 90
    and_test                       shift and go to state 86
    operand                        shift and go to state 81
    not_test                       shift and go to state 80
    factor                         shift and go to state 84
    array                          shift and go to state 60
    func_expr                      shift and go to state 61

state 228

    (81) for_stmt -> FOR ID : = NUMBER TO NUMBER . : suite

    :               shift and go to state 233


state 229

    (85) if_stmt -> IF expr : suite ELSE : suite .

    DEDENT          reduce using rule 85 (if_stmt -> IF expr : suite ELSE : suite .)
    ID              reduce using rule 85 (if_stmt -> IF expr : suite ELSE : suite .)
    FOR             reduce using rule 85 (if_stmt -> IF expr : suite ELSE : suite .)
    IF              reduce using rule 85 (if_stmt -> IF expr : suite ELSE : suite .)
    WHILE           reduce using rule 85 (if_stmt -> IF expr : suite ELSE : suite .)
    BREAK           reduce using rule 85 (if_stmt -> IF expr : suite ELSE : suite .)
    CONTINUE        reduce using rule 85 (if_stmt -> IF expr : suite ELSE : suite .)
    RETURN          reduce using rule 85 (if_stmt -> IF expr : suite ELSE : suite .)
    STRING          reduce using rule 85 (if_stmt -> IF expr : suite ELSE : suite .)
    NUMBER          reduce using rule 85 (if_stmt -> IF expr : suite ELSE : suite .)
    BOOLEAN         reduce using rule 85 (if_stmt -> IF expr : suite ELSE : suite .)
    NIL             reduce using rule 85 (if_stmt -> IF expr : suite ELSE : suite .)
    (               reduce using rule 85 (if_stmt -> IF expr : suite ELSE : suite .)
    [               reduce using rule 85 (if_stmt -> IF expr : suite ELSE : suite .)


state 230

    (87) elseif_stmt -> ELSEIF expr : . suite
    (90) suite -> . NEWLINE
    (91) suite -> . NEWLINE INDENT suite_stmt DEDENT

    NEWLINE         shift and go to state 133

    suite                          shift and go to state 234

state 231

    (86) if_stmt -> IF expr : suite elseif_stmt ELSE : . suite
    (90) suite -> . NEWLINE
    (91) suite -> . NEWLINE INDENT suite_stmt DEDENT

    NEWLINE         shift and go to state 133

    suite                          shift and go to state 235

state 232

    (88) elseif_stmt -> elseif_stmt ELSEIF expr . : suite

    :               shift and go to state 236


state 233

    (81) for_stmt -> FOR ID : = NUMBER TO NUMBER : . suite
    (90) suite -> . NEWLINE
    (91) suite -> . NEWLINE INDENT suite_stmt DEDENT

    NEWLINE         shift and go to state 133

    suite                          shift and go to state 237

state 234

    (87) elseif_stmt -> ELSEIF expr : suite .

    ELSE            reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    ELSEIF          reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    DEDENT          reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    ID              reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    FOR             reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    IF              reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    WHILE           reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    BREAK           reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    CONTINUE        reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    RETURN          reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    STRING          reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    NUMBER          reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    BOOLEAN         reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    NIL             reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    (               reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)
    [               reduce using rule 87 (elseif_stmt -> ELSEIF expr : suite .)


state 235

    (86) if_stmt -> IF expr : suite elseif_stmt ELSE : suite .

    DEDENT          reduce using rule 86 (if_stmt -> IF expr : suite elseif_stmt ELSE : suite .)
    ID              reduce using rule 86 (if_stmt -> IF expr : suite elseif_stmt ELSE : suite .)
    FOR             reduce using rule 86 (if_stmt -> IF expr : suite elseif_stmt ELSE : suite .)
    IF              reduce using rule 86 (if_stmt -> IF expr : suite elseif_stmt ELSE : suite .)
    WHILE           reduce using rule 86 (if_stmt -> IF expr : suite elseif_stmt ELSE : suite .)
    BREAK           reduce using rule 86 (if_stmt -> IF expr : suite elseif_stmt ELSE : suite .)
    CONTINUE        reduce using rule 86 (if_stmt -> IF expr : suite elseif_stmt ELSE : suite .)
    RETURN          reduce using rule 86 (if_stmt -> IF expr : suite elseif_stmt ELSE : suite .)
    STRING          reduce using rule 86 (if_stmt -> IF expr : suite elseif_stmt ELSE : suite .)
    NUMBER          reduce using rule 86 (if_stmt -> IF expr : suite elseif_stmt ELSE : suite .)
    BOOLEAN         reduce using rule 86 (if_stmt -> IF expr : suite elseif_stmt ELSE : suite .)
    NIL             reduce using rule 86 (if_stmt -> IF expr : suite elseif_stmt ELSE : suite .)
    (               reduce using rule 86 (if_stmt -> IF expr : suite elseif_stmt ELSE : suite .)
    [               reduce using rule 86 (if_stmt -> IF expr : suite elseif_stmt ELSE : suite .)


state 236

    (88) elseif_stmt -> elseif_stmt ELSEIF expr : . suite
    (90) suite -> . NEWLINE
    (91) suite -> . NEWLINE INDENT suite_stmt DEDENT

    NEWLINE         shift and go to state 133

    suite                          shift and go to state 238

state 237

    (81) for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .

    DEDENT          reduce using rule 81 (for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .)
    ID              reduce using rule 81 (for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .)
    FOR             reduce using rule 81 (for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .)
    IF              reduce using rule 81 (for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .)
    WHILE           reduce using rule 81 (for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .)
    BREAK           reduce using rule 81 (for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .)
    CONTINUE        reduce using rule 81 (for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .)
    RETURN          reduce using rule 81 (for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .)
    STRING          reduce using rule 81 (for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .)
    NUMBER          reduce using rule 81 (for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .)
    BOOLEAN         reduce using rule 81 (for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .)
    NIL             reduce using rule 81 (for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .)
    (               reduce using rule 81 (for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .)
    [               reduce using rule 81 (for_stmt -> FOR ID : = NUMBER TO NUMBER : suite .)


state 238

    (88) elseif_stmt -> elseif_stmt ELSEIF expr : suite .

    ELSE            reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    ELSEIF          reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    DEDENT          reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    ID              reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    FOR             reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    IF              reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    WHILE           reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    BREAK           reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    CONTINUE        reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    RETURN          reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    STRING          reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    NUMBER          reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    BOOLEAN         reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    NIL             reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    (               reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)
    [               reduce using rule 88 (elseif_stmt -> elseif_stmt ELSEIF expr : suite .)

